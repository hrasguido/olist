# -*- coding: utf-8 -*-
"""grupo 2 - notebook - sprint2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D_MDLGWXTrHEeB9jZVvoeXef1GASR0Ym

GRUPO 2

- Howar Rasguido Mejia
- Rumy Mamani Lucero
- Dieter Montenegro
"""

from google.colab import drive
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
from datetime import datetime
import warnings
import matplotlib.pyplot as plt

warnings.filterwarnings('ignore')

# montar google drive

drive.mount('/content/drive')

DATASET_DIR = '/content/drive/MyDrive/olist'

def eda_general(df, nombre_tabla):
    """
    Realiza un EDA completo para un DataFrame
    """
    print("\n" + "="*100)
    print(f"üìä EDA: {nombre_tabla.upper()}")
    print("="*100)

    # 1. INFORMACI√ìN B√ÅSICA
    print("\nüîπ 1. INFORMACI√ìN B√ÅSICA")
    print("-"*100)
    print(f"Dimensiones: {df.shape[0]:,} filas x {df.shape[1]} columnas")

    # 2. TIPOS DE DATOS
    print("\nüîπ 2. TIPOS DE DATOS")
    print("-"*100)
    print(df.dtypes)

    # 3. VALORES NULOS
    print("\nüîπ 3. VALORES NULOS")
    print("-"*100)
    null_counts = df.isnull().sum()
    null_pcts = (df.isnull().sum() / len(df)) * 100

    null_df = pd.DataFrame({
        'Columna': null_counts.index,
        'Nulos': null_counts.values,
        '% Nulos': null_pcts.values
    })
    null_df = null_df[null_df['Nulos'] > 0].sort_values('Nulos', ascending=False)

    if len(null_df) > 0:
        print(null_df.to_string(index=False))
        print(f"\n‚ö†Ô∏è  Total de valores nulos: {null_counts.sum():,}")
    else:
        print("‚úÖ No hay valores nulos")

    # 4. DUPLICADOS
    print("\nüîπ 4. DUPLICADOS")
    print("-"*100)
    duplicados_totales = df.duplicated().sum()
    print(f"Filas completamente duplicadas: {duplicados_totales:,}")

    return df

def get_orders_by_state(orders_df: pd.DataFrame, customers_df: pd.DataFrame) -> pd.DataFrame:
    """Calcula y retorna el conteo de √≥rdenes por customer_state (todos los estados)."""
    merged_df = orders_df.merge(customers_df, on='customer_id', how='inner')
    orders_by_state = merged_df.groupby('customer_state').size().reset_index(name='order_count')

    # Ordenar de forma descendente (sin limitar el top 10 a√∫n)
    orders_by_state = orders_by_state.sort_values(by='order_count', ascending=False)
    orders_by_state.columns = ['state_abbr', 'order_count']

    return orders_by_state

def plot_top_states_on_map(orders_df: pd.DataFrame, customers_df: pd.DataFrame, geolocation_df: pd.DataFrame):
    """
    Calcula el total de √≥rdenes por estado y grafica los estados en un mapa
    usando sus coordenadas geogr√°ficas promedio.
    """

    # a) Obtener el conteo de √≥rdenes por estado (usando la funci√≥n base)
    orders_by_state = get_orders_by_state(orders_df, customers_df)

    # b) Agregar la geolocalizaci√≥n para obtener una coordenada promedio por estado
    print("Calculando coordenadas promedio por estado...")
    geo_state_avg = geolocation_df.groupby('geolocation_state').agg({
        'geolocation_lat': 'mean',
        'geolocation_lng': 'mean'
    }).reset_index()

    # Renombrar para facilitar la uni√≥n
    geo_state_avg.columns = ['state_abbr', 'lat_avg', 'lng_avg']

    # c) Unir el conteo de √≥rdenes con las coordenadas promedio
    final_plot_data = orders_by_state.merge(
        geo_state_avg,
        on='state_abbr',
        how='inner'
    )

    # d) Obtener el top 10 para mostrar en las estad√≠sticas
    top_10_stats = final_plot_data.nlargest(10, 'order_count')

    print("\n--- Top 10 Estados por √ìrdenes ---")
    print(top_10_stats[['state_abbr', 'order_count']])

    # e) Crear el mapa interactivo con Plotly Express
    print("\nGenerando mapa interactivo...")

    fig = px.scatter_mapbox(
        final_plot_data,
        lat="lat_avg",
        lon="lng_avg",
        color="order_count",       # El color se basa en la cantidad de √≥rdenes
        size="order_count",        # El tama√±o del punto se basa en la cantidad de √≥rdenes
        hover_name="state_abbr",   # Mostrar el estado al pasar el rat√≥n
        hover_data={"order_count": True, "lat_avg": False, "lng_avg": False},
        color_continuous_scale=px.colors.sequential.Plasma,
        zoom=3, # Zoom inicial (√∫til para Brasil)
        height=650,
        title='Distribuci√≥n Geogr√°fica de √ìrdenes por Estado',
        mapbox_style="open-street-map" # Mapa base para mostrar en el mundo
    )

    fig.update_layout(margin={"r":0,"t":40,"l":0,"b":0})
    fig.show()

    return final_plot_data

def plot_payment_type_total_value(order_payments_df: pd.DataFrame):
    """
    Genera un gr√°fico de barras que muestra el valor total (suma de payment_value)
    para cada tipo de pago √∫nico (payment_type) con los valores anotados en las barras.

    Args:
        order_payments_df (pd.DataFrame): DataFrame con la informaci√≥n de los pagos.
    """

    # 1. Agrupar por payment_type y sumar payment_value
    payment_summary = order_payments_df.groupby('payment_type')['payment_value'].sum()

    # 2. Ordenar los resultados
    payment_summary = payment_summary.sort_values(ascending=False)

    # 3. Crear la figura y los ejes
    plt.figure(figsize=(12, 7))

    # Graficar y capturar el objeto Axes (ax)
    ax = payment_summary.plot(kind='bar', color='darkcyan', edgecolor='black')

    # 4. A√±adir las etiquetas de valor (MODIFICACI√ìN CLAVE)
    # Iteramos sobre los parches (las barras) del objeto Axes
    for p in ax.patches:
        # Obtener la altura de la barra (el valor de payment_value)
        value = p.get_height()
        # Obtener la posici√≥n X central de la barra
        x = p.get_x() + p.get_width() / 2

        # A√±adir el texto (formateado con separador de miles y 0 decimales)
        ax.annotate(
            f'${value:,.0f}', # Formato: S√≠mbolo de moneda y separador de miles
            (x, value),       # Posici√≥n (X, Y)
            ha='center',      # Alineaci√≥n horizontal: centrado
            va='bottom',      # Alineaci√≥n vertical: encima de la barra
            fontsize=10,
            fontweight='bold',
            xytext=(0, 5),    # Desplazamiento de 5 puntos hacia arriba
            textcoords='offset points'
        )

    # 5. Personalizar el gr√°fico
    plt.title('Suma Total del Valor de Pago por Tipo de Pago üíµ', fontsize=16, fontweight='bold')
    plt.xlabel('Tipo de Pago (payment_type)', fontsize=12)
    plt.ylabel('Suma Total del Valor de Pago (payment_value)', fontsize=12)
    plt.xticks(rotation=45, ha='right')
    plt.grid(axis='y', linestyle='--', alpha=0.5)
    plt.tight_layout()
    plt.show()

def plot_review_score_distribution(order_reviews_df: pd.DataFrame):
    """
    Genera un gr√°fico de barras que muestra la distribuci√≥n del conteo (frecuencia)
    de cada puntuaci√≥n de revisi√≥n √∫nica (review_score), con los valores
    totales anotados en las barras.

    Args:
        order_reviews_df (pd.DataFrame): DataFrame con la informaci√≥n de las revisiones.
    """

    # 1. Contar la frecuencia de cada review_score
    # Esto genera una Serie con las puntuaciones como √≠ndice y el conteo como valor.
    score_counts = order_reviews_df['review_score'].value_counts().sort_index()

    # 2. Crear la figura y los ejes
    plt.figure(figsize=(8, 6))

    # Graficar y capturar el objeto Axes (ax)
    ax = score_counts.plot(kind='bar', color='darkorange', edgecolor='black')

    # 3. A√±adir las etiquetas de valor (MODIFICACI√ìN CLAVE)
    # Iteramos sobre los parches (las barras) del objeto Axes
    for p in ax.patches:
        # Obtener la altura de la barra (el valor del conteo)
        count = p.get_height()
        # Obtener la posici√≥n X central de la barra
        x = p.get_x() + p.get_width() / 2

        # A√±adir el texto (formato entero, centrado)
        ax.annotate(
            f'{int(count):,}', # Formato: Entero con separador de miles
            (x, count),        # Posici√≥n (X, Y)
            ha='center',       # Alineaci√≥n horizontal: centrado
            va='bottom',       # Alineaci√≥n vertical: encima de la barra
            fontsize=11,
            fontweight='bold',
            xytext=(0, 5),     # Desplazamiento de 5 puntos hacia arriba
            textcoords='offset points'
        )

    # 4. Personalizar el gr√°fico
    plt.title('Distribuci√≥n de Puntuaciones de Revisi√≥n (1 a 5) ‚≠ê', fontsize=14, fontweight='bold')
    plt.xlabel('Puntuaci√≥n de Revisi√≥n (Review Score)', fontsize=12)
    plt.ylabel('Cantidad Total de Revisiones', fontsize=12)
    plt.xticks(rotation=0) # Mantener etiquetas de puntuaci√≥n horizontales
    plt.grid(axis='y', linestyle='--', alpha=0.5)
    plt.tight_layout()
    plt.show()

def plot_order_status_distribution(orders_df: pd.DataFrame):
    """
    Genera un gr√°fico de barras que muestra el conteo (frecuencia)
    de cada estado de la orden √∫nico (order_status), con los valores
    totales anotados en las barras.

    Args:
        orders_df (pd.DataFrame): DataFrame con la informaci√≥n de las √≥rdenes.
    """

    # 1. Contar la frecuencia de cada order_status
    # Esto genera una Serie con los estados como √≠ndice y el conteo como valor.
    # Ordenamos de forma descendente para mejor visualizaci√≥n.
    status_counts = orders_df['order_status'].value_counts().sort_values(ascending=False)

    # 2. Crear la figura y los ejes
    plt.figure(figsize=(12, 7))

    # Graficar y capturar el objeto Axes (ax)
    ax = status_counts.plot(kind='bar', color='darkblue', edgecolor='black')

    # 3. A√±adir las etiquetas de valor (anotaciones)
    # Iteramos sobre los parches (las barras) del objeto Axes
    for p in ax.patches:
        # Obtener la altura de la barra (el valor del conteo)
        count = p.get_height()
        # Obtener la posici√≥n X central de la barra
        x = p.get_x() + p.get_width() / 2

        # A√±adir el texto (formato entero, centrado)
        ax.annotate(
            f'{int(count):,}', # Formato: Entero con separador de miles
            (x, count),        # Posici√≥n (X, Y)
            ha='center',       # Alineaci√≥n horizontal: centrado
            va='bottom',       # Alineaci√≥n vertical: encima de la barra
            fontsize=10,
            fontweight='bold',
            xytext=(0, 5),     # Desplazamiento de 5 puntos hacia arriba
            textcoords='offset points'
        )

    # 4. Personalizar el gr√°fico
    plt.title('Distribuci√≥n de los Estados de la Orden', fontsize=16, fontweight='bold')
    plt.xlabel('Estado de la Orden (order_status)', fontsize=12)
    plt.ylabel('Cantidad Total de √ìrdenes', fontsize=12)
    plt.xticks(rotation=45, ha='right') # Rotar etiquetas para mejor lectura
    plt.grid(axis='y', linestyle='--', alpha=0.5)
    plt.tight_layout()
    plt.show()

import pandas as pd
import matplotlib.pyplot as plt

def analyze_delivery_timeline(orders_df: pd.DataFrame):
    """
    Analiza la evoluci√≥n mensual de las entregas, calcula las √≥rdenes entregadas
    a tiempo y grafica la evoluci√≥n mensual en un solo gr√°fico.

    Args:
        orders_df (pd.DataFrame): DataFrame de √≥rdenes.
    """

    # 1. PREPROCESAMIENTO DE FECHAS
    date_cols = [
        'order_purchase_timestamp',
        'order_delivered_customer_date',
        'order_estimated_delivery_date'
    ]
    for col in date_cols:
        # Usar .loc para asignar a una copia si es necesario, aunque .copy() ya se usar√° abajo
        orders_df[col] = pd.to_datetime(orders_df[col], errors='coerce')

    # 2. FILTRADO Y C√ÅLCULOS BASE

    # Filtrar solo pedidos entregados
    orders_delivered = orders_df[orders_df['order_status'] == 'delivered'].copy()

    # Calcular si fue entregado a tiempo (real <= estimado)
    orders_delivered['is_on_time'] = (
        orders_delivered['order_delivered_customer_date'] <=
        orders_delivered['order_estimated_delivery_date']
    ).astype(int)

    # Agrupar por mes de compra
    orders_delivered['purchase_month'] = orders_delivered['order_purchase_timestamp'].dt.to_period('M')

    # Calcular m√©tricas mensuales
    monthly_stats = orders_delivered.groupby('purchase_month').agg({
        'order_id': 'count',
        'is_on_time': 'sum'
    }).reset_index()

    monthly_stats.columns = ['purchase_month', 'total_delivered', 'on_time_delivered']
    monthly_stats['purchase_month'] = monthly_stats['purchase_month'].dt.to_timestamp()

    # 3. VISUALIZACI√ìN (SOLO EL PRIMER GR√ÅFICO)

    # Crear figura y un solo subplot (ax)
    fig, ax1 = plt.subplots(1, 1, figsize=(14, 7))

    # GR√ÅFICO 1: Cantidad de √≥rdenes (Total vs A Tiempo vs Retraso)
    ax1.plot(monthly_stats['purchase_month'], monthly_stats['total_delivered'],
             marker='o', linewidth=2, markersize=7, label='Total Entregadas', color='blue')
    ax1.plot(monthly_stats['purchase_month'], monthly_stats['on_time_delivered'],
             marker='s', linewidth=2, markersize=7, label='Entregadas a Tiempo', color='green')

    # √Årea entre las l√≠neas (√≥rdenes con retraso)
    ax1.fill_between(monthly_stats['purchase_month'],
                     monthly_stats['on_time_delivered'],
                     monthly_stats['total_delivered'],
                     alpha=0.3, color='red', label='Entregadas con Retraso')

    ax1.set_xlabel('Mes de Compra', fontsize=12)
    ax1.set_ylabel('Cantidad de √ìrdenes', fontsize=12)
    ax1.set_title('Evoluci√≥n de √ìrdenes Entregadas: Total vs A Tiempo', fontsize=14, fontweight='bold')
    ax1.legend(loc='best', fontsize=11)
    ax1.grid(True, alpha=0.3, linestyle='--')
    ax1.tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.show()

    # 4. ESTAD√çSTICAS GENERALES
    total_delivered_sum = monthly_stats['total_delivered'].sum()
    on_time_delivered_sum = monthly_stats['on_time_delivered'].sum()
    delayed_sum = total_delivered_sum - on_time_delivered_sum

    print("=" * 70)
    print("ESTAD√çSTICAS DE ENTREGAS")
    print("=" * 70)
    print(f"Total de √≥rdenes entregadas: {total_delivered_sum:,}")
    print(f"Total entregadas a tiempo: {on_time_delivered_sum:,}")
    print(f"Total con retraso: {delayed_sum:,}")
    print("=" * 70)

    return monthly_stats

def plot_monthly_category_sales_trend(orders_df: pd.DataFrame, order_items_df: pd.DataFrame, products_df: pd.DataFrame):
    """
    Genera un gr√°fico de l√≠neas que muestra la suma (conteo) de √≥rdenes para
    cada categor√≠a de producto vendida, a lo largo del tiempo (Mes y A√±o).

    Args:
        orders_df (pd.DataFrame): DataFrame de √≥rdenes.
        order_items_df (pd.DataFrame): DataFrame de √≠tems de √≥rdenes.
        products_df (pd.DataFrame): DataFrame de productos.
    """

    # --- Verificaci√≥n de Fechas ---
    if orders_df['order_purchase_timestamp'].isnull().all():
        print("ERROR: La columna 'order_purchase_timestamp' no contiene fechas v√°lidas. No se puede generar la serie de tiempo.")
        return

    # 1. PREPROCESAMIENTO TEMPORAL
    orders_df['purchase_month'] = orders_df['order_purchase_timestamp'].dt.to_period('M')

    # 2. UNI√ìN DE DATAFRAMES

    # Orders <- Order_Items (on order_id)
    df_merged = orders_df[['order_id', 'purchase_month']].merge(
        order_items_df[['order_id', 'product_id']],
        on='order_id',
        how='inner'
    )

    # df_merged <- Products (on product_id)
    df_merged = df_merged.merge(
        products_df[['product_id', 'product_category_name']],
        on='product_id',
        how='inner'
    )

    # 3. AGREGACI√ìN Y PREPARACI√ìN PARA GRAFICAR

    # Agrupar por Mes y Categor√≠a, y contar el total de √≠tems/√≥rdenes (Suma de cada categor√≠a)
    monthly_sales = df_merged.groupby(['purchase_month', 'product_category_name'])['order_id'].count().reset_index(name='sales_count')

    # Pivotar la tabla para que las categor√≠as sean columnas (Eje Y) y el mes sea el √≠ndice (Eje X)
    sales_pivot = monthly_sales.pivot(
        index='purchase_month',
        columns='product_category_name',
        values='sales_count'
    ).fillna(0) # Rellenar meses sin ventas de una categor√≠a con 0

    # Convertir a Timestamp para Matplotlib
    sales_pivot.index = sales_pivot.index.to_timestamp()

    # 4. GRAFICACI√ìN
    plt.figure(figsize=(16, 9))

    # Generar el gr√°fico de l√≠neas directamente desde la tabla pivotada
    sales_pivot.plot(kind='line', ax=plt.gca(), linewidth=2)

    # 5. Personalizaci√≥n del Gr√°fico
    plt.title('Evoluci√≥n Mensual del Volumen de √ìrdenes por Categor√≠a', fontsize=18, fontweight='bold')
    plt.xlabel('Mes de Compra', fontsize=14)
    plt.ylabel('Cantidad Total de √ìrdenes', fontsize=14)

    # Mover la leyenda fuera del gr√°fico si hay muchas categor√≠as
    plt.legend(title='Categor√≠a', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)

    plt.grid(True, linestyle='--', alpha=0.6)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

def plot_top_10_monthly_category_sales(orders_df: pd.DataFrame, order_items_df: pd.DataFrame, products_df: pd.DataFrame):
    """
    Identifica el Top 10 de categor√≠as por volumen de ventas total y grafica
    solo la evoluci√≥n mensual de esas 10 categor√≠as a lo largo del tiempo.

    Args:
        orders_df (pd.DataFrame): DataFrame de √≥rdenes.
        order_items_df (pd.DataFrame): DataFrame de √≠tems de √≥rdenes.
        products_df (pd.DataFrame): DataFrame de productos.
    """

    # --- Verificaci√≥n de Fechas ---
    if orders_df['order_purchase_timestamp'].isnull().all():
        print("ERROR: La columna 'order_purchase_timestamp' no contiene fechas v√°lidas. No se puede generar la serie de tiempo.")
        return

    # 1. PREPROCESAMIENTO TEMPORAL Y UNI√ìN

    orders_df['purchase_month'] = orders_df['order_purchase_timestamp'].dt.to_period('M')

    df_merged = orders_df[['order_id', 'purchase_month']].merge(
        order_items_df[['order_id', 'product_id']],
        on='order_id',
        how='inner'
    )

    df_merged = df_merged.merge(
        products_df[['product_id', 'product_category_name']],
        on='product_id',
        how='inner'
    )

    # 2. IDENTIFICAR EL TOP 10 DE CATEGOR√çAS (por volumen total)

    # Contar la venta total por categor√≠a
    category_totals = df_merged.groupby('product_category_name')['order_id'].count()

    # Obtener los nombres de las 10 categor√≠as m√°s vendidas
    top_10_categories = category_totals.nlargest(10).index.tolist()

    print(f"Top 10 categor√≠as seleccionadas para el gr√°fico: {top_10_categories}")
    print("-" * 70)

    # 3. FILTRADO Y AGREGACI√ìN MENSUAL

    # Filtrar el DataFrame combinado para incluir solo las categor√≠as del Top 10
    df_top_10 = df_merged[df_merged['product_category_name'].isin(top_10_categories)]

    # Agrupar por Mes y Categor√≠a, y contar el total de √≠tems/√≥rdenes (Suma de cada categor√≠a)
    monthly_sales = df_top_10.groupby(['purchase_month', 'product_category_name'])['order_id'].count().reset_index(name='sales_count')

    # Pivotar la tabla para que las categor√≠as sean columnas y el mes sea el √≠ndice
    sales_pivot = monthly_sales.pivot(
        index='purchase_month',
        columns='product_category_name',
        values='sales_count'
    ).fillna(0)

    # Convertir a Timestamp para Matplotlib
    sales_pivot.index = sales_pivot.index.to_timestamp()

    # 4. GRAFICACI√ìN
    plt.figure(figsize=(16, 9))

    # Generar el gr√°fico de l√≠neas con solo las 10 columnas (categor√≠as)
    sales_pivot.plot(kind='line', ax=plt.gca(), linewidth=2)

    # 5. Personalizaci√≥n del Gr√°fico
    plt.title('Evoluci√≥n Mensual del Volumen de √ìrdenes (Top 10 Categor√≠as)', fontsize=18, fontweight='bold')
    plt.xlabel('Mes de Compra', fontsize=14)
    plt.ylabel('Cantidad Total de √ìrdenes', fontsize=14)

    # Colocar la leyenda fuera del gr√°fico
    plt.legend(title='Categor√≠a', bbox_to_anchor=(1.01, 1), loc='upper left', fontsize=10)

    plt.grid(True, linestyle='--', alpha=0.6)
    plt.xticks(rotation=45)
    plt.tight_layout(rect=[0, 0, 0.9, 1]) # Ajuste para que la leyenda quepa
    plt.show()

import pandas as pd
import matplotlib.pyplot as plt

def plot_top_10_post_oct_2017_sales(orders_df: pd.DataFrame, order_items_df: pd.DataFrame, products_df: pd.DataFrame):
    """
    Identifica y grafica la evoluci√≥n mensual del Top 10 de categor√≠as.

    El Top 10 se calcula bas√°ndose solo en el volumen de √≥rdenes de '2017-10' en adelante.

    Args:
        orders_df (pd.DataFrame): DataFrame de √≥rdenes.
        order_items_df (pd.DataFrame): DataFrame de √≠tems de √≥rdenes.
        products_df (pd.DataFrame): DataFrame de productos.
    """

    # 1. PREPROCESAMIENTO TEMPORAL Y UNI√ìN

    # Manejo de la columna de tiempo (Se asume que los datos est√°n corregidos)
    if orders_df['order_purchase_timestamp'].isnull().all():
        print("ERROR: La columna 'order_purchase_timestamp' no contiene fechas v√°lidas. No se puede generar la serie de tiempo.")
        return

    orders_df['purchase_month'] = orders_df['order_purchase_timestamp'].dt.to_period('M')

    df_merged = orders_df[['order_id', 'purchase_month']].merge(
        order_items_df[['order_id', 'product_id']],
        on='order_id',
        how='inner'
    )

    df_merged = df_merged.merge(
        products_df[['product_id', 'product_category_name']],
        on='product_id',
        how='inner'
    )

    # 2. FILTRADO TEMPORAL Y C√ÅLCULO DEL TOP 10 (MODIFICACI√ìN CLAVE)

    # Definir la fecha de inicio para el c√°lculo del Top 10 (Octubre de 2017)
    start_date_period = pd.Period('2017-10', freq='M')

    # Filtrar el DataFrame combinado solo con datos a partir de 2017-10
    df_filtered_for_ranking = df_merged[
        df_merged['purchase_month'] >= start_date_period
    ]

    # Contar la venta total por categor√≠a en este per√≠odo filtrado
    category_totals_filtered = df_filtered_for_ranking.groupby('product_category_name')['order_id'].count()

    # Obtener los nombres de las 10 categor√≠as m√°s vendidas en el per√≠odo
    top_10_categories = category_totals_filtered.nlargest(10).index.tolist()

    print(f"Top 10 categor√≠as seleccionadas (basado en ventas post-{start_date_period}): {top_10_categories}")
    print("-" * 70)

    # 3. FILTRADO DEL GR√ÅFICO Y AGREGACI√ìN MENSUAL (Usando TODO el per√≠odo disponible para el gr√°fico)

    # Filtrar el DataFrame original (df_merged) para incluir solo el Top 10 de categor√≠as
    df_top_10 = df_merged[df_merged['product_category_name'].isin(top_10_categories)]

    # Agrupar por Mes y Categor√≠a, y contar el total de √≥rdenes
    monthly_sales = df_top_10.groupby(['purchase_month', 'product_category_name'])['order_id'].count().reset_index(name='sales_count')

    # Pivotar la tabla
    sales_pivot = monthly_sales.pivot(
        index='purchase_month',
        columns='product_category_name',
        values='sales_count'
    ).fillna(0)

    # Convertir a Timestamp para Matplotlib
    sales_pivot.index = sales_pivot.index.to_timestamp()

    # 4. GRAFICACI√ìN
    plt.figure(figsize=(16, 9))

    sales_pivot.plot(kind='line', ax=plt.gca(), linewidth=2)

    plt.title(f'Evoluci√≥n Mensual del Volumen de √ìrdenes (Top 10 Categor√≠as post-{start_date_period.strftime("%Y-%m")})', fontsize=16, fontweight='bold')
    plt.xlabel('Mes de Compra', fontsize=12)
    plt.ylabel('Cantidad Total de √ìrdenes', fontsize=12)

    plt.legend(title='Categor√≠a', bbox_to_anchor=(1.01, 1), loc='upper left', fontsize=10)

    plt.grid(True, linestyle='--', alpha=0.6)
    plt.xticks(rotation=45)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    plt.show()

def get_orders_by_seller_state(orders_items_df: pd.DataFrame, sellers_df: pd.DataFrame) -> pd.DataFrame:
    """
    Calcula la suma de √≥rdenes √∫nicas por el estado del vendedor.

    Args:
        orders_items_df (pd.DataFrame): DataFrame de items de √≥rdenes.
        sellers_df (pd.DataFrame): DataFrame de vendedores.

    Returns:
        pd.DataFrame: Tabla con 'seller_state' y 'total_orders', ordenada descendentemente.
    """

    # 1. Unir order_items con sellers en 'seller_id'
    seller_order_link = orders_items_df.merge(
        sellers_df[['seller_id', 'seller_state']],
        on='seller_id',
        how='inner'
    )

    # 2. Contar √≥rdenes √∫nicas por estado
    orders_by_state = seller_order_link.groupby('seller_state')['order_id'].nunique().reset_index(name='total_orders')

    # 3. Ordenar el resultado
    orders_by_state_sorted = orders_by_state.sort_values(by='total_orders', ascending=False)

    return orders_by_state_sorted

# Diccionario para almacenar todos los datasets
datasets = {}

# leer archivos csv

customers = pd.read_csv(os.path.join(DATASET_DIR, 'olist_customers_dataset.csv'))
geolocation = pd.read_csv(os.path.join(DATASET_DIR, 'olist_geolocation_dataset.csv'))
order_items = pd.read_csv(os.path.join(DATASET_DIR, 'olist_order_items_dataset.csv'))
order_payments = pd.read_csv(os.path.join(DATASET_DIR, 'olist_order_payments_dataset.csv'))
order_reviews = pd.read_csv(os.path.join(DATASET_DIR, 'olist_order_reviews_dataset.csv'))
orders = pd.read_csv(os.path.join(DATASET_DIR, 'olist_orders_dataset.csv'))
sellers = pd.read_csv(os.path.join(DATASET_DIR, 'olist_sellers_dataset.csv'))
category_translation = pd.read_csv(os.path.join(DATASET_DIR, 'product_category_name_translation.csv'))

# 1. CUSTOMERS

datasets['customers'] = eda_general(customers, 'CUSTOMERS')

get_orders_by_state(orders, customers)

# 2. GEOLOCATION

datasets['geolocation'] = eda_general(geolocation, 'GEOLOCATION')
unique_states = geolocation['geolocation_state'].unique()
print(unique_states)
print(f"Total de estados √∫nicos: {len(unique_states)}")

# 3. ORDER ITEMS

datasets['order_items'] = eda_general(order_items, 'ORDER ITEMS')

# 4. ORDER PAYMENTS

datasets['order_payments'] = eda_general(order_payments, 'ORDER PAYMENTS')
plot_payment_type_total_value(order_payments)

# 5. ORDER REVIEWS

datasets['order_reviews'] = eda_general(order_reviews, 'ORDER REVIEWS')
plot_review_score_distribution(order_reviews)

# 6. ORDERS

datasets['orders'] = eda_general(orders, 'ORDERS')
plot_order_status_distribution(orders)
analyze_delivery_timeline(orders)

# 7. PRODUCTS

products = pd.read_csv(os.path.join(DATASET_DIR, 'olist_products_dataset.csv'))
datasets['products'] = eda_general(products, 'PRODUCTS')
plot_monthly_category_sales_trend(orders, order_items, products)
plot_top_10_monthly_category_sales(orders, order_items, products)
#plot_top_10_post_oct_2017_sales(orders, order_items, products)

# 8. SELLERS

datasets['sellers'] = eda_general(sellers, 'SELLERS')
result_table = get_orders_by_seller_state(order_items, sellers)
print(result_table)

# 9. CATEGORY TRANSLATION

datasets['category_translation'] = eda_general(category_translation, 'CATEGORY TRANSLATION')

# ============================================================================
# AN√ÅLISIS ESPEC√çFICO PARA EL PROYECTO DE RETRASOS
# ============================================================================

print("\n" + "="*100)
print("üéØ AN√ÅLISIS ESPEC√çFICO: DETECCI√ìN DE RETRASOS EN ENTREGAS")
print("="*100)

# Convertir fechas a datetime
date_columns = ['order_purchase_timestamp', 'order_approved_at',
                'order_delivered_carrier_date', 'order_delivered_customer_date',
                'order_estimated_delivery_date']

for col in date_columns:
    if col in orders.columns:
        orders[col] = pd.to_datetime(orders[col], errors='coerce')

# Filtrar solo pedidos entregados
orders_delivered = orders[orders['order_status'] == 'delivered'].copy()

print(f"\nüì¶ Total de pedidos: {len(orders):,}")
print(f"üì¶ Pedidos entregados: {len(orders_delivered):,} ({len(orders_delivered)/len(orders)*100:.2f}%)")


# Calcular variable objetivo
orders_delivered['is_late_delivery'] = (
    orders_delivered['order_delivered_customer_date'] >
    orders_delivered['order_estimated_delivery_date']
).astype(int)

print("\nüéØ VARIABLE OBJETIVO: is_late_delivery")
print("-"*100)
print(orders_delivered['is_late_delivery'].value_counts())
print("\nDistribuci√≥n porcentual:")
print(orders_delivered['is_late_delivery'].value_counts(normalize=True) * 100)


# Calcular features temporales
orders_delivered['promised_delivery_days'] = (
    orders_delivered['order_estimated_delivery_date'] -
    orders_delivered['order_approved_at']
).dt.days

orders_delivered['actual_delivery_days'] = (
    orders_delivered['order_delivered_customer_date'] -
    orders_delivered['order_approved_at']
).dt.days

orders_delivered['delay_days'] = (
    orders_delivered['order_delivered_customer_date'] -
    orders_delivered['order_estimated_delivery_date']
).dt.days

print("\nüìä ESTAD√çSTICAS DE TIEMPOS DE ENTREGA:")
print("-"*100)
print(f"D√≠as prometidos (promedio): {orders_delivered['promised_delivery_days'].mean():.2f}")
print(f"D√≠as reales (promedio): {orders_delivered['actual_delivery_days'].mean():.2f}")
print(f"Retraso promedio: {orders_delivered['delay_days'].mean():.2f} d√≠as")
print(f"Retraso m√°ximo: {orders_delivered['delay_days'].max():.2f} d√≠as")
print(f"Adelanto m√°ximo: {orders_delivered['delay_days'].min():.2f} d√≠as")

# 2. Distribuci√≥n de tiempos de entrega

# Gr√°fico 1: D√≠as Prometidos de Entrega
plt.figure(figsize=(6, 5))
plt.hist(orders_delivered['promised_delivery_days'].dropna(), bins=50, color='skyblue', edgecolor='black')
plt.title('D√≠as Prometidos de Entrega', fontweight='bold')
plt.xlabel('D√≠as')
plt.ylabel('Frecuencia')
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# Gr√°fico 2: D√≠as Reales de Entrega
plt.figure(figsize=(6, 5))
plt.hist(orders_delivered['actual_delivery_days'].dropna(), bins=50, color='lightcoral', edgecolor='black')
plt.title('D√≠as Reales de Entrega', fontweight='bold')
plt.xlabel('D√≠as')
plt.ylabel('Frecuencia')
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# Gr√°fico 3: D√≠as de Retraso/Adelanto
plt.figure(figsize=(6, 5))
plt.hist(orders_delivered['delay_days'].dropna(), bins=50, color='orange', edgecolor='black')
plt.title('D√≠as de Retraso/Adelanto', fontweight='bold')
plt.xlabel('D√≠as (negativo = adelanto)')
plt.ylabel('Frecuencia')
plt.axvline(x=0, color='red', linestyle='--', linewidth=2, label='Sin retraso')
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# Calcular variable objetivo
orders_delivered['is_late_delivery'] = (
    orders_delivered['order_delivered_customer_date'] >
    orders_delivered['order_estimated_delivery_date']
).astype(int)

print("\nüéØ VARIABLE OBJETIVO: is_late_delivery")
print("-"*100)
print(orders_delivered['is_late_delivery'].value_counts())
print("\nDistribuci√≥n porcentual:")
print(orders_delivered['is_late_delivery'].value_counts(normalize=True) * 100)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def plot_target_distribution_series(target_series: pd.Series):
    """
    Grafica la distribuci√≥n de la variable objetivo (retraso en la entrega)
    con estilos profesionales, incluyendo porcentajes sobre las barras.

    Args:
        target_series (pd.Series): La serie de la variable objetivo (1: Retrasado, 0: A Tiempo).
    """

    # Aplicar estilo de Seaborn consistente
    sns.set_style("whitegrid")

    plt.figure(figsize=(10, 6))

    # 1. Preparaci√≥n de datos y paleta de colores
    # La paleta es consistente: Verde para la mayor√≠a (A Tiempo), Rojo para la minor√≠a (Retraso)
    colors = ['forestgreen', 'firebrick']

    # Convertir a DataFrame para usar sns.countplot, si target_series es una serie de Pandas.
    # Usamos value_counts() para asegurar el orden.
    counts_df = target_series.value_counts().reset_index()
    counts_df.columns = ['is_late_delivery', 'count']

    # 2. Generar el gr√°fico con Seaborn
    ax = sns.barplot(
        x='is_late_delivery',
        y='count',
        data=counts_df,
        palette=colors,
        order=[0, 1] # Asegura el orden 0, 1 en el eje X
    )

    # 3. Ajustes de T√≠tulo y Ejes
    plt.title('Distribuci√≥n de Entregas: A Tiempo vs Retrasadas', fontsize=16, fontweight='bold', y=1.03)
    plt.xlabel('\n¬øEntrega Retrasada?', fontsize=12)
    plt.ylabel('Cantidad de Pedidos', fontsize=12)

    # Ajustar etiquetas X (Seaborn usa los valores del data)
    ax.set_xticklabels(['A Tiempo (0)', 'Retrasado (1)'])

    # 4. A√±adir el porcentaje sobre las barras (destacando el desbalance)
    total = target_series.count()
    for p in ax.patches:
        height = p.get_height()
        percentage = '{:.1f}%'.format(100 * height / total)
        x = p.get_x() + p.get_width() / 2
        ax.annotate(percentage, (x, height), ha='center', va='bottom', fontsize=11, fontweight='bold')

    plt.tight_layout()
    plt.show()

# --- Ejemplo de Uso ---
# NOTA: Para ejecutar esto, se debe crear la serie de datos simulada.

# 1. Simulaci√≥n de la Serie (replicando el desbalance ~92% vs ~8%)
np.random.seed(42)
target_data_simulated = pd.Series(
    np.random.choice([0, 1], size=10000, p=[0.92, 0.08]),
    name='is_late_delivery'
)

plot_target_distribution_series(orders_delivered['is_late_delivery'])

"""# Detecci√≥n de retrasos en la entrega de pedidos

# Variables temporales

```
| Variable                  | Descripci√≥n                                                                                           | Tipo       |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ---------- |
| `purchase_day_of_week`    | D√≠a de la semana en que se hizo el pedido (lunes, martes, etc.)                                       | categ√≥rica |
| `purchase_hour`           | Hora del d√≠a del pedido                                                                               | num√©rica   |
| `days_to_approve`         | Diferencia entre `order_approved_at` y `order_purchase_timestamp`                                     | num√©rica   |
| `days_to_carrier`         | Tiempo entre `order_approved_at` y `order_delivered_carrier_date` (tiempo hasta que sale del almac√©n) | num√©rica   |
| `estimated_delivery_days` | D√≠as entre `order_estimated_delivery_date` y `order_purchase_timestamp`                               | num√©rica   |
| `month` o `season`        | Mes o estaci√≥n del a√±o (pueden afectar la log√≠stica, ej. Black Friday o Navidad)                      | categ√≥rica |

```
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def generate_temporal_features(orders_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera variables de tiempo clave para el an√°lisis de retrasos en el DataFrame orders.

    Args:
        orders_df (pd.DataFrame): DataFrame de √≥rdenes.

    Returns:
        pd.DataFrame: DataFrame de √≥rdenes con las nuevas columnas de features.
    """
    df = orders_df.copy()

    # --- 1. CONVERSI√ìN ROBUSTA DE FECHAS ---
    date_cols = [
        'order_purchase_timestamp',
        'order_approved_at',
        'order_delivered_carrier_date',
        'order_estimated_delivery_date'
    ]
    for col in date_cols:
        # Usar errors='coerce' para convertir datos no v√°lidos en NaT (Not a Time)
        df[col] = pd.to_datetime(df[col], errors='coerce')

    # --- 2. GENERACI√ìN DE FEATURES ---

    # 1. purchase_day_of_week (Categ√≥rica)
    # day_name() devuelve el nombre del d√≠a de la semana
    df['purchase_day_of_week'] = df['order_purchase_timestamp'].dt.day_name(locale='en_US.UTF-8')

    # 2. purchase_hour (Num√©rica)
    df['purchase_hour'] = df['order_purchase_timestamp'].dt.hour

    # 3. days_to_approve (Num√©rica)
    # Diferencia entre aprobaci√≥n y compra, convertida a d√≠as
    df['days_to_approve'] = (
        df['order_approved_at'] - df['order_purchase_timestamp']
    ).dt.total_seconds() / (60 * 60 * 24)
    # Reemplazar valores negativos (errores de registro) con NaN
    df.loc[df['days_to_approve'] < 0, 'days_to_approve'] = np.nan

    # 4. days_to_carrier (Num√©rica)
    # Tiempo desde aprobaci√≥n hasta entrega a transportista
    df['days_to_carrier'] = (
        df['order_delivered_carrier_date'] - df['order_approved_at']
    ).dt.total_seconds() / (60 * 60 * 24)
    df.loc[df['days_to_carrier'] < 0, 'days_to_carrier'] = np.nan

    # 5. estimated_delivery_days (Num√©rica)
    # D√≠as entre fecha de compra y fecha estimada de entrega
    df['estimated_delivery_days'] = (
        df['order_estimated_delivery_date'] - df['order_purchase_timestamp']
    ).dt.total_seconds() / (60 * 60 * 24)
    df.loc[df['estimated_delivery_days'] < 0, 'estimated_delivery_days'] = np.nan

    # 6. month o season (Categ√≥rica) - Usaremos month_name para claridad
    df['purchase_month'] = df['order_purchase_timestamp'].dt.month_name(locale='en_US.UTF-8')

    # Mantenemos solo las columnas relevantes
    features = df[[
        'order_id',
        'purchase_day_of_week',
        'purchase_hour',
        'days_to_approve',
        'days_to_carrier',
        'estimated_delivery_days',
        'purchase_month'
    ]].copy()

    return features

def plot_temporal_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features temporales.
    """
    print("\n--- Generando Gr√°ficos de Features Temporales ---")

    # --- Configuraci√≥n de Gr√°ficos ---
    sns.set_style("whitegrid")

    # 1. Variables Categ√≥ricas (Frecuencia)
    fig, axes = plt.subplots(1, 2, figsize=(16, 5))

    # D√≠a de la semana (purchase_day_of_week)
    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    sns.countplot(
        x='purchase_day_of_week',
        data=features_df,
        order=day_order,
        palette='viridis',
        ax=axes[0]
    )
    axes[0].set_title('Distribuci√≥n de Pedidos por D√≠a de la Semana')
    axes[0].set_xlabel('D√≠a de la Semana')
    axes[0].set_ylabel('Conteo de √ìrdenes')
    axes[0].tick_params(axis='x', rotation=45)

    # Mes de compra (purchase_month)
    month_order = list(pd.to_datetime(['2020-' + str(m) for m in range(1, 13)]).strftime('%B'))
    sns.countplot(
        x='purchase_month',
        data=features_df,
        order=month_order,
        palette='plasma',
        ax=axes[1]
    )
    axes[1].set_title('Distribuci√≥n de Pedidos por Mes')
    axes[1].set_xlabel('Mes')
    axes[1].set_ylabel('Conteo de √ìrdenes')
    axes[1].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.show()

    # 2. Variables Num√©ricas (Distribuci√≥n)
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))

    # purchase_hour (Hora del d√≠a)
    sns.histplot(features_df['purchase_hour'].dropna(), bins=24, kde=True, color='skyblue', ax=axes[0])
    axes[0].set_title('Distribuci√≥n de Pedidos por Hora del D√≠a')
    axes[0].set_xlabel('Hora del Pedido')
    axes[0].set_ylabel('Frecuencia')

    # days_to_approve (Tiempo de Aprobaci√≥n)
    # Se limita el eje X para evitar outliers extremos y visualizar la densidad
    sns.histplot(features_df['days_to_approve'].dropna(), bins=50, kde=True, color='lightcoral', ax=axes[1])
    axes[1].set_title('Distribuci√≥n de D√≠as hasta Aprobaci√≥n')
    axes[1].set_xlabel('D√≠as')
    axes[1].set_xlim(0, features_df['days_to_approve'].quantile(0.99))

    # days_to_carrier (Tiempo hasta Transportista)
    sns.histplot(features_df['days_to_carrier'].dropna(), bins=50, kde=True, color='mediumseagreen', ax=axes[2])
    axes[2].set_title('Distribuci√≥n de D√≠as hasta Entrega a Transportista')
    axes[2].set_xlabel('D√≠as')
    axes[2].set_xlim(0, features_df['days_to_carrier'].quantile(0.99))

    plt.tight_layout()
    plt.show()

def plot_purchase_hour_distribution(features_df: pd.DataFrame):
    """
    Grafica la distribuci√≥n de pedidos por hora del d√≠a.
    """
    sns.set_style("whitegrid")
    plt.figure(figsize=(7, 5))
    sns.histplot(features_df['purchase_hour'].dropna(), bins=24, kde=True, color='skyblue')
    plt.title('Distribuci√≥n de Pedidos por Hora del D√≠a')
    plt.xlabel('Hora del Pedido')
    plt.ylabel('Frecuencia')
    plt.tight_layout()
    plt.show()

temporal_features_df = generate_temporal_features(orders)
#print(temporal_features_df.head())
plot_temporal_features(temporal_features_df)

"""# Variables log√≠sticas

```
| Variable                          | Descripci√≥n                                                                                       | Tipo       |
| --------------------------------- | ------------------------------------------------------------------------------------------------- | ---------- |
| `freight_value`                   | Costo del env√≠o (puede relacionarse con distancia o tipo de transporte)                           | num√©rica   |
| `shipping_distance`               | Distancia entre vendedor y comprador (a partir de `geolocation` o estado)                         | num√©rica   |
| `seller_state` y `customer_state` | Estados del vendedor y comprador (√∫tiles para modelar distancias regionales)                      | categ√≥rica |
| `number_of_sellers`               | N√∫mero de vendedores en un pedido (m√°s vendedores puede = m√°s complejidad log√≠stica)              | num√©rica   |
| `number_of_items`                 | N√∫mero total de productos en un pedido                                                            | num√©rica   |
| `total_weight`                    | Peso total del pedido (sumando pesos de `product_id`)                                             | num√©rica   |
| `total_volume`                    | Volumen total del pedido (basado en `product_length_cm`, `product_height_cm`, `product_width_cm`) | num√©rica   |

```
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calcula la distancia Haversine (en km) entre dos puntos geogr√°ficos."""
    R = 6371  # Radio de la Tierra en kil√≥metros

    lat1_rad, lon1_rad = radians(lat1), radians(lon1)
    lat2_rad, lon2_rad = radians(lat2), radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    a = sin(dlat / 2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))

    distance = R * c
    return distance

def generate_logistics_features(orders_df: pd.DataFrame, order_items_df: pd.DataFrame,
                                products_df: pd.DataFrame, sellers_df: pd.DataFrame,
                                customers_df: pd.DataFrame, geolocation_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features de flete, peso, volumen, distancia y complejidad del pedido.

    Retorna un DataFrame de √≥rdenes con las nuevas columnas de features.
    """

    # --- 1. PREPARACI√ìN Y LIMPIEZA DE DATOS ---

    # 1.1. Conversi√≥n de Claves (Asegurar que las claves de uni√≥n sean del mismo tipo)
    for df in [orders_df, customers_df, order_items_df, sellers_df]:
        for col in ['order_id', 'customer_id', 'seller_id', 'product_id']:
            if col in df.columns:
                df[col] = df[col].astype(str)

    # 1.2. Limpieza y c√°lculo de volumen/peso de productos
    product_physical_cols = ['product_weight_g', 'product_length_cm', 'product_height_cm', 'product_width_cm']
    for col in product_physical_cols:
        products_df[col] = pd.to_numeric(products_df[col], errors='coerce').fillna(0)

    products_df['product_volume_cm3'] = products_df['product_length_cm'] * products_df['product_height_cm'] * products_df['product_width_cm']
    products_df['product_volume_cm3'] = products_df['product_volume_cm3'].fillna(0)

    # Merge order_items con productos
    order_items_products = order_items_df.merge(
        products_df[['product_id', 'product_weight_g', 'product_volume_cm3']],
        on='product_id',
        how='left'
    )

    # --- 2. C√ÅLCULO DE FEATURES AGREGADAS POR ORDEN ---

    logistics_features_df = order_items_products.groupby('order_id').agg(
        freight_value=('freight_value', 'sum'),
        number_of_items=('order_item_id', 'count'),
        number_of_sellers=('seller_id', 'nunique'),
        total_weight=('product_weight_g', 'sum'),
        total_volume=('product_volume_cm3', 'sum')
    ).reset_index()

    # --- 3. C√ÅLCULO DE FEATURES GEOGR√ÅFICAS (ESTADOS) ---

    # Estado del Vendedor (Usando el estado del primer vendedor como proxy)
    order_seller_state = order_items_df.sort_values('order_item_id').drop_duplicates('order_id').merge(
        sellers_df[['seller_id', 'seller_state']],
        on='seller_id',
        how='left'
    )[['order_id', 'seller_state']]

    # Estado del Cliente
    order_customer_state = orders_df[['order_id', 'customer_id']].merge(
        customers_df[['customer_id', 'customer_state']],
        on='customer_id',
        how='left'
    )

    logistics_features_df = logistics_features_df.merge(order_seller_state, on='order_id', how='left')
    logistics_features_df = logistics_features_df.merge(order_customer_state[['order_id', 'customer_state']], on='order_id', how='left')

    # Llenar NaN en estados con 'UNKNOWN' para modelado
    logistics_features_df['seller_state'] = logistics_features_df['seller_state'].fillna('UNKNOWN')
    logistics_features_df['customer_state'] = logistics_features_df['customer_state'].fillna('UNKNOWN').astype(str)


    # --- 4. C√ÅLCULO DE SHIPPING_DISTANCE (REQUIERE DATA SANA) ---

    # Pre-procesar Geolocation (Promediar lat/lng por zip code)
    geo_df = geolocation_df[['geolocation_zip_code_prefix', 'geolocation_lat', 'geolocation_lng']].copy()
    geo_df['geolocation_zip_code_prefix'] = pd.to_numeric(geo_df['geolocation_zip_code_prefix'], errors='coerce')
    geo_df_clean = geo_df.groupby('geolocation_zip_code_prefix').agg(
        lat=('geolocation_lat', 'mean'),
        lng=('geolocation_lng', 'mean')
    ).reset_index()

    # Obtener el zip_code del comprador y vendedor para cada orden
    customer_zip = customers_df[['customer_id', 'customer_zip_code_prefix']].merge(
        orders_df[['customer_id', 'order_id']], on='customer_id', how='right'
    )
    seller_zip = sellers_df[['seller_id', 'seller_zip_code_prefix']].merge(
        order_items_df[['seller_id', 'order_id']].drop_duplicates(), on='seller_id', how='right'
    )

    # La columna customer_zip_code_prefix en customers es int64, la convertimos a num√©rica antes de merge
    customer_zip['customer_zip_code_prefix'] = pd.to_numeric(customer_zip['customer_zip_code_prefix'], errors='coerce')
    seller_zip['seller_zip_code_prefix'] = pd.to_numeric(seller_zip['seller_zip_code_prefix'], errors='coerce')


    # Combinar zips con coordenadas geogr√°ficas
    df_distance = customer_zip.merge(
        seller_zip, on='order_id', how='inner'
    ).merge(
        geo_df_clean.rename(columns={'geolocation_zip_code_prefix': 'customer_zip_code_prefix', 'lat': 'cust_lat', 'lng': 'cust_lng'}),
        on='customer_zip_code_prefix', how='left'
    ).merge(
        geo_df_clean.rename(columns={'geolocation_zip_code_prefix': 'seller_zip_code_prefix', 'lat': 'seller_lat', 'lng': 'seller_lng'}),
        on='seller_zip_code_prefix', how='left'
    )

    # Calcular distancia Haversine
    df_distance['shipping_distance'] = df_distance.apply(
        lambda row: haversine_distance(row['cust_lat'], row['cust_lng'], row['seller_lat'], row['seller_lng'])
        if all(pd.notna(row[['cust_lat', 'cust_lng', 'seller_lat', 'seller_lng']])) else np.nan,
        axis=1
    )

    # Merge final de la distancia
    logistics_features_df = logistics_features_df.merge(
        df_distance[['order_id', 'shipping_distance']],
        on='order_id',
        how='left'
    )

    return logistics_features_df

def plot_logistics_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features log√≠sticas.
    """
    print("\n--- Generando Gr√°ficos de Features Log√≠sticas y de Complejidad ---")

    sns.set_style("whitegrid")

    # Filtrar para evitar la dominancia de valores cero/nulos en el c√°lculo de l√≠mites
    plot_df = features_df.copy()

    fig, axes = plt.subplots(3, 2, figsize=(18, 15))
    fig.suptitle('Distribuci√≥n de Features de Log√≠stica y Complejidad del Pedido', fontsize=18, fontweight='bold', y=1.02)

    # --- Row 1: Numeric Distributions (Freight and Weight) ---

    # 1. freight_value
    safe_freight_limit = plot_df['freight_value'].quantile(0.95) if plot_df['freight_value'].quantile(0.95) > 0 else plot_df['freight_value'].max()
    sns.histplot(plot_df['freight_value'].dropna(), bins=50, kde=True, color='skyblue', ax=axes[0, 0])
    axes[0, 0].set_title('1. Distribuci√≥n del Costo de Env√≠o (Freight Value)')
    if safe_freight_limit > 0 and not np.isinf(safe_freight_limit):
        axes[0, 0].set_xlim(0, safe_freight_limit)

    # 2. total_weight
    safe_weight_limit = plot_df['total_weight'].quantile(0.95) if plot_df['total_weight'].quantile(0.95) > 0 else plot_df['total_weight'].max()
    sns.histplot(plot_df['total_weight'].dropna(), bins=50, kde=True, color='lightcoral', ax=axes[0, 1])
    axes[0, 1].set_title('2. Distribuci√≥n del Peso Total del Pedido (g)')
    if safe_weight_limit > 0 and not np.isinf(safe_weight_limit):
        axes[0, 1].set_xlim(0, safe_weight_limit)

    # --- Row 2: Complexity Features (Items and Sellers) ---

    # 3. number_of_items
    sns.countplot(x='number_of_items', data=plot_df, palette='viridis', ax=axes[1, 0])
    axes[1, 0].set_title('3. Conteo de Pedidos por N√∫mero de Art√≠culos')
    axes[1, 0].set_xlim(-0.5, plot_df['number_of_items'].max() + 0.5)

    # 4. number_of_sellers
    sns.countplot(x='number_of_sellers', data=plot_df, palette='plasma', ax=axes[1, 1])
    axes[1, 1].set_title('4. Conteo de Pedidos por N√∫mero de Vendedores')
    axes[1, 1].set_xlim(-0.5, plot_df['number_of_sellers'].max() + 0.5)

    # --- Row 3: Categorical/Distance Features ---

    # 5. seller_state (Top 10)
    top_10_seller_states = plot_df['seller_state'].value_counts().nlargest(10).index
    sns.countplot(y='seller_state', data=plot_df, order=top_10_seller_states, palette='magma', ax=axes[2, 0])
    axes[2, 0].set_title('5. Distribuci√≥n de Pedidos por Estado del Vendedor')

    # 6. shipping_distance
    limit_distance = plot_df['shipping_distance'].quantile(0.99)
    sns.histplot(plot_df['shipping_distance'].dropna(), bins=50, kde=True, color='grey', ax=axes[2, 1])
    axes[2, 1].set_title('6. Distribuci√≥n de la Distancia de Env√≠o (Km)')
    axes[2, 1].set_xlabel('Distancia (Km)')
    if limit_distance > 0 and not np.isinf(limit_distance): axes[2, 1].set_xlim(0, limit_distance)

    plt.tight_layout()
    plt.show()

def plot_seller_state_distribution(features_df: pd.DataFrame):
    sns.set_style("whitegrid")
    plt.figure(figsize=(8, 5))
    top_states = features_df['seller_state'].value_counts().nlargest(10).index
    sns.countplot(y='seller_state', data=features_df, order=top_states, palette='magma')
    plt.title('Distribuci√≥n de Pedidos por Estado del Vendedor')
    plt.tight_layout()
    plt.show()

def plot_shipping_distance_distribution(features_df: pd.DataFrame):
    sns.set_style("whitegrid")
    plt.figure(figsize=(7, 5))
    limit_distance = features_df['shipping_distance'].quantile(0.99)
    sns.histplot(features_df['shipping_distance'].dropna(), bins=50, kde=True, color='grey')
    plt.title('Distribuci√≥n de la Distancia de Env√≠o (Km)')
    plt.xlabel('Distancia (Km)')
    if limit_distance > 0 and not np.isinf(limit_distance):
        plt.xlim(0, limit_distance)
    plt.tight_layout()
    plt.show()

logistics_features_df = generate_logistics_features(orders, order_items, products, sellers, customers, geolocation)
plot_logistics_features(logistics_features_df)

"""# Variables de producto y categor√≠a

```
| Variable                         | Descripci√≥n                                   | Tipo       |
| -------------------------------- | --------------------------------------------- | ---------- |
| `most_frequent_product_category` | Categor√≠a m√°s com√∫n en el pedido              | categ√≥rica |
| `num_unique_categories`          | N√∫mero de categor√≠as distintas por pedido     | num√©rica   |
| `avg_product_price`              | Promedio de precios de productos en el pedido | num√©rica   |
| `total_price`                    | Suma de precios en el pedido                  | num√©rica   |

```
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def most_frequent(series):
    """Devuelve el primer valor de la moda de una serie, o NaN si est√° vac√≠a."""
    # .mode() devuelve una Serie. Tomamos el primer elemento (m√°s frecuente).
    mode_val = series.mode()
    return mode_val.iloc[0] if not mode_val.empty else np.nan

def generate_product_features(order_items_df: pd.DataFrame, products_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features de producto y precio a nivel de pedido (order_id)
    uniendo order_items y products.
    """

    # --- 1. PREPARACI√ìN Y MERGE ---

    # Asegurar que las claves de uni√≥n sean strings (soluci√≥n a problemas previos)
    order_items_df['product_id'] = order_items_df['product_id'].astype(str)
    products_df['product_id'] = products_df['product_id'].astype(str)

    # 1. Merge order_items con products para obtener categor√≠a
    order_items_products = order_items_df.merge(
        products_df[['product_id', 'product_category_name']],
        on='product_id',
        how='left'
    )

    # 2. Convertir la columna 'price' a num√©rica de forma robusta
    order_items_products['price'] = pd.to_numeric(order_items_products['price'], errors='coerce')


    # --- 2. C√ÅLCULO DE FEATURES AGREGADAS ---

    product_features = order_items_products.groupby('order_id').agg(
        # total_price
        total_price=('price', 'sum'),
        # avg_product_price
        avg_product_price=('price', 'mean'),
        # num_unique_categories
        num_unique_categories=('product_category_name', 'nunique'),
        # most_frequent_product_category
        most_frequent_product_category=('product_category_name', most_frequent)
    ).reset_index()

    # Manejar NaN en la categor√≠a: Si no hay categor√≠a, usa 'unknown'
    product_features['most_frequent_product_category'] = product_features['most_frequent_product_category'].fillna('unknown')

    return product_features

def plot_product_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features de producto y precio.
    """
    print("\n--- Generando Gr√°ficos de Features de Producto y Precio ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Distribuci√≥n de Features de Producto y Precio por Pedido', fontsize=18, fontweight='bold', y=1.02)

    # 1. total_price (Num√©rica)
    # Limitar el eje X al 99% para visualizar la densidad sin outliers
    safe_price_limit = features_df['total_price'].quantile(0.99)
    sns.histplot(features_df['total_price'].dropna(), bins=50, kde=True, color='purple', ax=axes[0, 0])
    axes[0, 0].set_title('1. Distribuci√≥n del Precio Total del Pedido')
    axes[0, 0].set_xlabel('Precio Total (R$)')
    if not np.isnan(safe_price_limit) and safe_price_limit > 0:
        axes[0, 0].set_xlim(0, safe_price_limit)

    # 2. avg_product_price (Num√©rica)
    safe_avg_price_limit = features_df['avg_product_price'].quantile(0.99)
    sns.histplot(features_df['avg_product_price'].dropna(), bins=50, kde=True, color='orange', ax=axes[0, 1])
    axes[0, 1].set_title('2. Distribuci√≥n del Precio Promedio por Producto')
    axes[0, 1].set_xlabel('Precio Promedio (R$)')
    if not np.isnan(safe_avg_price_limit) and safe_avg_price_limit > 0:
        axes[0, 1].set_xlim(0, safe_avg_price_limit)

    # 3. num_unique_categories (Num√©rica/Categ√≥rica)
    num_unique_categories_data = features_df['num_unique_categories'].dropna()
    if not num_unique_categories_data.empty:
        sns.countplot(x='num_unique_categories', data=features_df, palette='deep', ax=axes[1, 0])
        axes[1, 0].set_title('3. N√∫mero de Categor√≠as √önicas por Pedido')
        axes[1, 0].set_xlabel('N√∫mero de Categor√≠as √önicas')
        axes[1, 0].set_xlim(-0.5, num_unique_categories_data.max() + 0.5)
    else:
        axes[1, 0].set_title('3. N√∫mero de Categor√≠as √önicas por Pedido (Datos Vac√≠os)')

    # 4. most_frequent_product_category (Categ√≥rica)
    # Mostrar el Top 10 de categor√≠as m√°s frecuentes
    top_categories = features_df['most_frequent_product_category'].value_counts().nlargest(10).index
    if not top_categories.empty:
        plot_data_categories = features_df[features_df['most_frequent_product_category'].isin(top_categories)]
        sns.countplot(y='most_frequent_product_category', data=plot_data_categories, order=top_categories, palette='viridis', ax=axes[1, 1])
        axes[1, 1].set_title('4. Top 10 Categor√≠as M√°s Frecuentes')
        axes[1, 1].set_xlabel('Conteo de Pedidos')
    else:
        axes[1, 1].set_title('4. Top 10 Categor√≠as M√°s Frecuentes (Datos Vac√≠os)')

    plt.tight_layout()
    plt.show()

product_features_df = generate_product_features(order_items, products)
# print(product_features_df.head())
plot_product_features(product_features_df)

"""# Variables de pago

```


| Variable               | Descripci√≥n                                            | Tipo       |
| ---------------------- | ------------------------------------------------------ | ---------- |
| `payment_type`         | Tipo de pago (`credit_card`, `boleto`, etc.)           | categ√≥rica |
| `payment_installments` | N√∫mero de cuotas                                       | num√©rica   |
| `payment_value`        | Valor total pagado                                     | num√©rica   |
| `payment_delay_risk`   | Proxy: si el pago fue con ‚Äúboleto‚Äù (puede demorar m√°s) | binaria    |

```


```
"""

def generate_payment_features(order_payments_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features de pago a nivel de pedido (order_id).
    """
    df = order_payments_df.copy()

    # --- 1. PREPARACI√ìN ---
    df['order_id'] = df['order_id'].astype(str)
    df['payment_value'] = pd.to_numeric(df['payment_value'], errors='coerce')
    df['payment_installments'] = pd.to_numeric(df['payment_installments'], errors='coerce').fillna(0).astype(int)

    # --- 2. C√ÅLCULO DE LA VARIABLE BINARIA DE RIESGO ---
    # payment_delay_risk: 1 si alguno de los pagos fue con 'boleto', 0 en caso contrario.
    df['is_boleto'] = np.where(df['payment_type'] == 'boleto', 1, 0)


    # --- 3. C√ÅLCULO DE FEATURES AGREGADAS ---

    # Agregaci√≥n: Sumamos el valor, tomamos el valor m√°ximo de cuotas y si hubo alg√∫n boleto
    payment_features = df.groupby('order_id').agg(
        # payment_value: Suma total pagada
        payment_value=('payment_value', 'sum'),
        # payment_installments: M√°ximo n√∫mero de cuotas (ya que suelen ser iguales o relevantes)
        payment_installments=('payment_installments', 'max'),
        # payment_type: Tipo de pago m√°s frecuente (usamos el primero de la moda)
        payment_type=('payment_type', lambda x: x.mode().iloc[0] if not x.mode().empty else 'unknown'),
        # payment_delay_risk: Si el pedido tuvo al menos un pago con boleto
        payment_delay_risk=('is_boleto', 'max')
    ).reset_index()

    # Si hay NaN en payment_value, rellenar con 0
    payment_features['payment_value'] = payment_features['payment_value'].fillna(0)

    return payment_features

def plot_payment_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features de pago.
    """
    print("\n--- Generando Gr√°ficos de Features de Pago ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Distribuci√≥n de Features de Pago por Pedido', fontsize=18, fontweight='bold', y=1.02)

    # 1. payment_type (Categ√≥rica)
    sns.countplot(y='payment_type', data=features_df, order=features_df['payment_type'].value_counts().index, palette='tab10', ax=axes[0, 0])
    axes[0, 0].set_title('1. Distribuci√≥n por Tipo de Pago M√°s Frecuente')
    axes[0, 0].set_xlabel('Conteo de Pedidos')

    # 2. payment_value (Num√©rica)
    safe_value_limit = features_df['payment_value'].quantile(0.99)
    sns.histplot(features_df['payment_value'].dropna(), bins=50, kde=True, color='teal', ax=axes[0, 1])
    axes[0, 1].set_title('2. Distribuci√≥n del Valor Total del Pago')
    axes[0, 1].set_xlabel('Valor Total Pagado (R$)')
    if not np.isnan(safe_value_limit) and safe_value_limit > 0:
        axes[0, 1].set_xlim(0, safe_value_limit)

    # 3. payment_installments (Num√©rica)
    sns.countplot(x='payment_installments', data=features_df, color='darkred', ax=axes[1, 0])
    axes[1, 0].set_title('3. Conteo por N√∫mero M√°ximo de Cuotas')
    axes[1, 0].set_xlabel('N√∫mero de Cuotas')
    # Enfocarse en las primeras 12 cuotas
    axes[1, 0].set_xlim(-0.5, 12.5)

    # 4. payment_delay_risk (Binaria)
    sns.countplot(x='payment_delay_risk', data=features_df, palette=['forestgreen', 'firebrick'], ax=axes[1, 1])
    axes[1, 1].set_title('4. Riesgo de Retraso por Tipo de Pago (Boleto)')
    axes[1, 1].set_xlabel('1 = Pago con Boleto (Riesgo), 0 = Sin Boleto')

    plt.tight_layout()
    plt.show()

payment_features_df = generate_payment_features(order_payments)
# print(payment_features_df.head())
plot_payment_features(payment_features_df)

"""# Variables del cliente

```
| Variable                  | Descripci√≥n                                                                               | Tipo       |
| ------------------------- | ----------------------------------------------------------------------------------------- | ---------- |
| `customer_state`          | Estado del cliente                                                                        | categ√≥rica |
| `customer_city`           | Ciudad (quiz√°s codificada en clusters)                                                    | categ√≥rica |
| `num_previous_orders`     | N√∫mero de pedidos previos del mismo cliente (puede correlacionar con confianza log√≠stica) | num√©rica   |
| `avg_previous_delay_rate` | Porcentaje de retrasos anteriores del cliente (si se tiene hist√≥rico)                     | num√©rica   |

```
"""

def generate_customer_features(orders_df: pd.DataFrame, customers_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features geogr√°ficas y de historial de pedidos del cliente.
    """

    # --- 1. PREPARACI√ìN Y MERGE ---

    # Asegurar que las claves de uni√≥n sean strings
    orders_df['customer_id'] = orders_df['customer_id'].astype(str)
    customers_df['customer_id'] = customers_df['customer_id'].astype(str)

    # Merge orders con customers para obtener ubicaci√≥n y unique_id
    df_merged = orders_df.merge(
        customers_df[['customer_id', 'customer_unique_id', 'customer_state', 'customer_city']],
        on='customer_id',
        how='left'
    )

    # --- 2. C√ÅLCULO DE LA VARIABLE TARGET (is_delayed) ---
    # Convertir fechas a datetime
    date_cols = ['order_delivered_customer_date', 'order_estimated_delivery_date']
    for col in date_cols:
        df_merged[col] = pd.to_datetime(df_merged[col], errors='coerce')

    # El pedido se retrasa si la entrega real fue posterior a la estimada.
    df_merged['is_delayed'] = (
        df_merged['order_delivered_customer_date'] > df_merged['order_estimated_delivery_date']
    ).astype(int)
    # Excluir pedidos que nunca se entregaron (NaN en order_delivered_customer_date)
    df_merged.loc[df_merged['order_delivered_customer_date'].isna(), 'is_delayed'] = np.nan


    # --- 3. C√ÅLCULO DE FEATURES HIST√ìRICAS ---

    # Para calcular el hist√≥rico, usamos la funci√≥n rank para simular el orden de compra
    df_merged['purchase_timestamp'] = pd.to_datetime(df_merged['order_purchase_timestamp'], errors='coerce')
    df_merged = df_merged.sort_values(by=['customer_unique_id', 'purchase_timestamp'])

    # 3.1. num_previous_orders (N√∫mero de pedidos previos)
    # Calculamos el n√∫mero de pedidos antes del pedido actual (-1 porque es el pedido actual)
    df_merged['num_previous_orders'] = df_merged.groupby('customer_unique_id').cumcount()

    # 3.2. avg_previous_delay_rate (Tasa de retraso promedio anterior)
    # Calculamos el retraso acumulado (suma) y el conteo acumulado
    df_merged['cumulative_delay_sum'] = df_merged.groupby('customer_unique_id')['is_delayed'].transform(lambda x: x.shift(1).cumsum())
    df_merged['cumulative_order_count'] = df_merged.groupby('customer_unique_id')['is_delayed'].transform(lambda x: x.shift(1).notna().cumsum())

    # La tasa de retraso anterior es (suma de retrasos anteriores) / (conteo de pedidos anteriores)
    df_merged['avg_previous_delay_rate'] = (
        df_merged['cumulative_delay_sum'] / df_merged['cumulative_order_count']
    )
    # Los clientes con su primer pedido tendr√°n NaN o 0/0, rellenamos con 0 (sin historial = 0 retraso)
    df_merged['avg_previous_delay_rate'] = df_merged['avg_previous_delay_rate'].fillna(0)

    # --- 4. SELECCI√ìN DE FEATURES ---
    customer_features = df_merged[[
        'order_id',
        'customer_unique_id',
        'customer_state',
        'customer_city',
        'num_previous_orders',
        'avg_previous_delay_rate'
    ]].copy()

    return customer_features

def plot_customer_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features geogr√°ficas y de historial del cliente.
    """
    print("\n--- Generando Gr√°ficos de Features de Cliente e Historial ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Distribuci√≥n de Features de Cliente e Historial', fontsize=18, fontweight='bold', y=1.02)

    # 1. customer_state (Top 10)
    top_10_states = features_df['customer_state'].value_counts().nlargest(10).index
    sns.countplot(y='customer_state', data=features_df, order=top_10_states, palette='viridis', ax=axes[0, 0])
    axes[0, 0].set_title('1. Distribuci√≥n de Pedidos por Estado del Cliente (Top 10)')
    axes[0, 0].set_xlabel('Conteo de Pedidos')

    # 2. num_previous_orders (Hist√≥rico)
    # Mayor√≠a de los clientes son de primera compra (0 pedidos previos)
    sns.countplot(x='num_previous_orders', data=features_df, palette='plasma', ax=axes[0, 1])
    axes[0, 1].set_title('2. N√∫mero de Pedidos Previos del Cliente')
    axes[0, 1].set_xlabel('N√∫mero de Pedidos Previos')
    # Limitar el eje X para mostrar los recuentos m√°s comunes (0, 1, 2)
    axes[0, 1].set_xlim(-0.5, features_df['num_previous_orders'].max() + 0.5)

    # 3. avg_previous_delay_rate (Tasa de retraso anterior)
    # Distribuci√≥n de la tasa (0 a 1)
    sns.histplot(features_df['avg_previous_delay_rate'].dropna(), bins=20, kde=True, color='darkred', ax=axes[1, 0])
    axes[1, 0].set_title('3. Distribuci√≥n de la Tasa de Retraso Hist√≥rica Promedio')
    axes[1, 0].set_xlabel('Tasa de Retraso Anterior (0.0 a 1.0)')
    axes[1, 0].set_xlim(0, 1)

    # 4. customer_city (Top 10 - Demasiadas categor√≠as, solo top)
    top_10_cities = features_df['customer_city'].value_counts().nlargest(10).index
    sns.countplot(y='customer_city', data=features_df, order=top_10_cities, palette='tab20', ax=axes[1, 1])
    axes[1, 1].set_title('4. Distribuci√≥n de Pedidos por Ciudad (Top 10)')
    axes[1, 1].set_xlabel('Conteo de Pedidos')

    plt.tight_layout()
    plt.show()

customer_features_df = generate_customer_features(orders, customers)
plot_customer_features(customer_features_df)

"""# Features temporales

```
| Nueva variable              | F√≥rmula / Fuente                                               | Significado                                                                         |
| --------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| `days_to_approve`           | `order_approved_at - order_purchase_timestamp`                 | Tiempo en que el pago fue aprobado. Retrasos en aprobaci√≥n pueden impactar entrega. |
| `days_to_carrier`           | `order_delivered_carrier_date - order_approved_at`             | Tiempo entre aprobaci√≥n y despacho. Si es largo, hay riesgo de retraso.             |
| `estimated_delivery_days`   | `order_estimated_delivery_date - order_purchase_timestamp`     | D√≠as estimados por el sistema.                                                      |
| `purchase_day_of_week`      | D√≠a de la semana (`order_purchase_timestamp`)                  | Hay patrones de demanda (por ejemplo, lunes puede tener m√°s retrasos).              |
| `purchase_month`            | Mes del a√±o                                                    | Puede reflejar estacionalidad (Navidad, Black Friday, etc.).                        |
| `purchase_hour`             | Hora del d√≠a                                                   | Pedidos hechos de noche pueden procesarse m√°s tarde.                                |
| `days_in_transit_estimated` | `order_estimated_delivery_date - order_delivered_carrier_date` | Tiempo estimado de transporte (planeado).                                           |

```
"""

def generate_temporal_features(orders_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera variables de tiempo clave (d√≠as de procesamiento y estacionalidad)
    a partir del DataFrame orders.
    """
    df = orders_df.copy()

    # --- Conversi√≥n Robusta de Fechas ---
    date_cols = [
        'order_purchase_timestamp',
        'order_approved_at',
        'order_delivered_carrier_date',
        'order_estimated_delivery_date'
    ]
    for col in date_cols:
        # Usa errors='coerce' para convertir valores no v√°lidos o corruptos a NaT (Not a Time)
        df[col] = pd.to_datetime(df[col], errors='coerce')

    # --- Generaci√≥n de Features de Duraci√≥n (en D√≠as) ---

    # 1. days_to_approve: Tiempo de aprobaci√≥n
    df['days_to_approve'] = (
        df['order_approved_at'] - df['order_purchase_timestamp']
    ).dt.total_seconds() / (60 * 60 * 24)
    df.loc[df['days_to_approve'] < 0, 'days_to_approve'] = np.nan # Limpiar valores negativos

    # 2. days_to_carrier: Tiempo entre aprobaci√≥n y despacho
    df['days_to_carrier'] = (
        df['order_delivered_carrier_date'] - df['order_approved_at']
    ).dt.total_seconds() / (60 * 60 * 24)
    df.loc[df['days_to_carrier'] < 0, 'days_to_carrier'] = np.nan

    # 3. estimated_delivery_days: D√≠as totales estimados para la entrega (Purchase -> Estimated)
    df['estimated_delivery_days'] = (
        df['order_estimated_delivery_date'] - df['order_purchase_timestamp']
    ).dt.total_seconds() / (60 * 60 * 24)
    df.loc[df['estimated_delivery_days'] < 0, 'estimated_delivery_days'] = np.nan

    # 4. days_in_transit_estimated: Tiempo estimado de transporte (Carrier -> Estimated)
    df['days_in_transit_estimated'] = (
        df['order_estimated_delivery_date'] - df['order_delivered_carrier_date']
    ).dt.total_seconds() / (60 * 60 * 24)
    df.loc[df['days_in_transit_estimated'] < 0, 'days_in_transit_estimated'] = np.nan


    # --- Generaci√≥n de Features de Estacionalidad ---

    # 5. purchase_day_of_week
    # Usamos locale 'en_US' para asegurar nombres consistentes
    df['purchase_day_of_week'] = df['order_purchase_timestamp'].dt.day_name(locale='en_US.UTF-8')

    # 6. purchase_month
    df['purchase_month'] = df['order_purchase_timestamp'].dt.month_name(locale='en_US.UTF-8')

    # 7. purchase_hour
    df['purchase_hour'] = df['order_purchase_timestamp'].dt.hour

    # Retornar las columnas relevantes
    features = df[[
        'order_id',
        'days_to_approve',
        'days_to_carrier',
        'estimated_delivery_days',
        'days_in_transit_estimated',
        'purchase_day_of_week',
        'purchase_month',
        'purchase_hour'
    ]].copy()

    return features

def plot_temporal_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features temporales, enfoc√°ndose en la distribuci√≥n
    y el comportamiento c√≠clico.
    """
    print("\n--- Generando Gr√°ficos de Features Temporales ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(3, 2, figsize=(18, 15))
    fig.suptitle('Distribuci√≥n de Features de Tiempo y Estacionalidad', fontsize=18, fontweight='bold', y=1.02)

    # --- Row 1: Tiempos de Procesamiento (Distribuci√≥n) ---

    # 1. days_to_approve
    # Limitar el eje X al 99% para excluir outliers extremos
    limit_approve = features_df['days_to_approve'].quantile(0.99)
    sns.histplot(features_df['days_to_approve'].dropna(), bins=50, kde=True, color='lightcoral', ax=axes[0, 0])
    axes[0, 0].set_title('1. Distribuci√≥n de D√≠as hasta Aprobaci√≥n (Procesamiento de Pago)')
    axes[0, 0].set_xlabel('D√≠as')
    if limit_approve > 0: axes[0, 0].set_xlim(0, limit_approve)

    # 2. days_to_carrier
    limit_carrier = features_df['days_to_carrier'].quantile(0.99)
    sns.histplot(features_df['days_to_carrier'].dropna(), bins=50, kde=True, color='mediumseagreen', ax=axes[0, 1])
    axes[0, 1].set_title('2. Distribuci√≥n de D√≠as hasta Despacho (Carrier)')
    axes[0, 1].set_xlabel('D√≠as')
    if limit_carrier > 0: axes[0, 1].set_xlim(0, limit_carrier)

    # --- Row 2: Tiempos Estimados (Distribuci√≥n) ---

    # 3. estimated_delivery_days
    limit_estimated = features_df['estimated_delivery_days'].quantile(0.99)
    sns.histplot(features_df['estimated_delivery_days'].dropna(), bins=50, kde=True, color='gold', ax=axes[1, 0])
    axes[1, 0].set_title('3. D√≠as de Entrega Estimados (Total)')
    axes[1, 0].set_xlabel('D√≠as')
    if limit_estimated > 0: axes[1, 0].set_xlim(0, limit_estimated)

    # 4. days_in_transit_estimated
    limit_transit = features_df['days_in_transit_estimated'].quantile(0.99)
    sns.histplot(features_df['days_in_transit_estimated'].dropna(), bins=50, kde=True, color='cadetblue', ax=axes[1, 1])
    axes[1, 1].set_title('4. D√≠as Estimados en Tr√°nsito (Carrier -> Estimated)')
    axes[1, 1].set_xlabel('D√≠as')
    if limit_transit > 0: axes[1, 1].set_xlim(0, limit_transit)

    # --- Row 3: Estacionalidad (Frecuencia) ---

    # 5. purchase_day_of_week
    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    sns.countplot(
        x='purchase_day_of_week',
        data=features_df,
        order=day_order,
        palette='viridis',
        ax=axes[2, 0]
    )
    axes[2, 0].set_title('5. Distribuci√≥n de Pedidos por D√≠a de la Semana')
    axes[2, 0].tick_params(axis='x', rotation=45)

    # 6. purchase_hour
    sns.histplot(features_df['purchase_hour'].dropna(), bins=24, kde=False, color='skyblue', ax=axes[2, 1])
    axes[2, 1].set_title('6. Distribuci√≥n de Pedidos por Hora del D√≠a')
    axes[2, 1].set_xlabel('Hora del Pedido')
    axes[2, 1].set_xticks(np.arange(0, 24, 2))

    plt.tight_layout()
    plt.show()

temporal_features_df = generate_temporal_features(orders)
plot_temporal_features(temporal_features_df)

"""# Features de logistica y envio

```
| Nueva variable             | F√≥rmula / Fuente                                                                                                     | Significado                                   |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| `freight_per_item`         | `freight_value / order_item_count`                                                                                   | Mide costo log√≠stico por √≠tem.                |
| `freight_ratio`            | `freight_value / total_price`                                                                                        | Qu√© proporci√≥n del total representa el flete. |
| `order_item_count`         | `count(order_id)` en `order_items`                                                                                   | Tama√±o del pedido.                            |
| `num_sellers`              | `nunique(seller_id)` en `order_items`                                                                                | M√°s vendedores = m√°s complejidad log√≠stica.   |
| `total_weight`             | suma(`product_weight_g`) por pedido                                                                                  | Peso total del pedido.                        |
| `total_volume`             | suma(`product_length_cm * product_height_cm * product_width_cm`)                                                     | Volumen total.                                |
| `avg_shipping_cost_per_kg` | `freight_value / total_weight`                                                                                       | Relaci√≥n costo‚Äìpeso.                          |
| `shipping_distance_km`     | Distancia estimada entre `customer_state` y `seller_state` (usando centroides geogr√°ficos o una tabla de distancias) | Factor de riesgo log√≠stico clave.             |

```
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from math import radians, sin, cos, sqrt, atan2

# --- Funci√≥n Helper para Distancia Haversine (Necesaria para shipping_distance) ---
def haversine_distance(lat1, lon1, lat2, lon2):
    """Calcula la distancia Haversine (en km) entre dos puntos geogr√°ficos."""
    R = 6371  # Radio de la Tierra en kil√≥metros
    lat1_rad, lon1_rad = radians(lat1), radians(lon1)
    lat2_rad, lon2_rad = radians(lat2), radians(lon2)
    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad
    a = sin(dlat / 2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = R * c
    return distance


def generate_logistics_features(orders_df: pd.DataFrame, order_items_df: pd.DataFrame,
                                products_df: pd.DataFrame, sellers_df: pd.DataFrame,
                                customers_df: pd.DataFrame, geolocation_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features de peso, volumen, complejidad (count, sellers) y ratios de flete.
    """

    # --- 1. PREPARACI√ìN Y MERGE ---

    # Asegurar que las claves de uni√≥n sean strings
    for df in [orders_df, customers_df, order_items_df, sellers_df, products_df]:
        for col in ['order_id', 'customer_id', 'seller_id', 'product_id']:
            if col in df.columns:
                df[col] = df[col].astype(str)

    # Limpieza y c√°lculo de volumen/peso de productos
    product_physical_cols = ['product_weight_g', 'product_length_cm', 'product_height_cm', 'product_width_cm']
    for col in product_physical_cols:
        products_df[col] = pd.to_numeric(products_df[col], errors='coerce').fillna(0)

    products_df['product_volume_cm3'] = products_df['product_length_cm'] * products_df['product_height_cm'] * products_df['product_width_cm']
    products_df['product_volume_cm3'] = products_df['product_volume_cm3'].fillna(0)

    # Merge order_items con productos para obtener dimensiones
    order_items_products = order_items_df.merge(
        products_df[['product_id', 'product_weight_g', 'product_volume_cm3']],
        on='product_id',
        how='left'
    )
    # Convertir 'price' y 'freight_value' a num√©rico
    order_items_products['price'] = pd.to_numeric(order_items_products['price'], errors='coerce').fillna(0)
    order_items_products['freight_value'] = pd.to_numeric(order_items_products['freight_value'], errors='coerce').fillna(0)


    # --- 2. C√ÅLCULO DE FEATURES BASE POR ORDEN ---

    logistics_features_base = order_items_products.groupby('order_id').agg(
        # order_item_count (count(order_id))
        order_item_count=('order_item_id', 'count'),
        # num_sellers (nunique(seller_id))
        num_sellers=('seller_id', 'nunique'),
        # total_weight
        total_weight=('product_weight_g', 'sum'),
        # total_volume
        total_volume=('product_volume_cm3', 'sum'),
        # freight_value
        freight_value=('freight_value', 'sum'),
        # total_price (base para freight_ratio)
        total_price=('price', 'sum')
    ).reset_index()

    # --- 3. C√ÅLCULO DE SHIPPING_DISTANCE (REQUIERE DATA SANA) ---

    # Pre-procesar Geolocation (Promediar lat/lng por zip code)
    geo_df = geolocation_df[['geolocation_zip_code_prefix', 'geolocation_lat', 'geolocation_lng']].copy()
    geo_df['geolocation_zip_code_prefix'] = pd.to_numeric(geo_df['geolocation_zip_code_prefix'], errors='coerce')
    geo_df_clean = geo_df.groupby('geolocation_zip_code_prefix').agg(
        lat=('geolocation_lat', 'mean'),
        lng=('geolocation_lng', 'mean')
    ).reset_index()

    # Obtener el zip_code del comprador y vendedor para cada orden
    customer_zip = customers_df[['customer_id', 'customer_zip_code_prefix']].merge(
        orders_df[['customer_id', 'order_id']], on='customer_id', how='right'
    )
    seller_zip = sellers_df[['seller_id', 'seller_zip_code_prefix']].merge(
        order_items_df[['seller_id', 'order_id']].drop_duplicates(), on='seller_id', how='right'
    )

    # Convertir zips a num√©rica antes de merge
    customer_zip['customer_zip_code_prefix'] = pd.to_numeric(customer_zip['customer_zip_code_prefix'], errors='coerce')
    seller_zip['seller_zip_code_prefix'] = pd.to_numeric(seller_zip['seller_zip_code_prefix'], errors='coerce')


    # Combinar zips con coordenadas geogr√°ficas
    df_distance = customer_zip.merge(
        seller_zip, on='order_id', how='inner'
    ).merge(
        geo_df_clean.rename(columns={'geolocation_zip_code_prefix': 'customer_zip_code_prefix', 'lat': 'cust_lat', 'lng': 'cust_lng'}),
        on='customer_zip_code_prefix', how='left'
    ).merge(
        geo_df_clean.rename(columns={'geolocation_zip_code_prefix': 'seller_zip_code_prefix', 'lat': 'seller_lat', 'lng': 'seller_lng'}),
        on='seller_zip_code_prefix', how='left'
    )

    # Calcular distancia Haversine
    df_distance['shipping_distance_km'] = df_distance.apply(
        lambda row: haversine_distance(row['cust_lat'], row['cust_lng'], row['seller_lat'], row['seller_lng'])
        if all(pd.notna(row[['cust_lat', 'cust_lng', 'seller_lat', 'seller_lng']])) else np.nan,
        axis=1
    )

    # Merge final de la distancia
    logistics_features_df = logistics_features_base.merge(
        df_distance[['order_id', 'shipping_distance_km']],
        on='order_id',
        how='left'
    )

    # --- 4. C√ÅLCULO DE FEATURES DERIVADAS ---

    # freight_per_item
    logistics_features_df['freight_per_item'] = np.where(
        logistics_features_df['order_item_count'] > 0,
        logistics_features_df['freight_value'] / logistics_features_df['order_item_count'],
        0
    )

    # freight_ratio
    logistics_features_df['freight_ratio'] = np.where(
        logistics_features_df['total_price'] > 0,
        logistics_features_df['freight_value'] / logistics_features_df['total_price'],
        np.nan # Si el precio total es 0, la divisi√≥n no tiene sentido
    )

    # avg_shipping_cost_per_kg
    logistics_features_df['avg_shipping_cost_per_kg'] = np.where(
        logistics_features_df['total_weight'] > 0,
        logistics_features_df['freight_value'] / logistics_features_df['total_weight'],
        np.nan
    )

    return logistics_features_df

def plot_derived_logistics_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features log√≠sticas derivadas.
    """
    print("\n--- Generando Gr√°ficos de Features Log√≠sticas Derivadas ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(3, 2, figsize=(16, 15))
    fig.suptitle('Distribuci√≥n de Features Log√≠sticas Derivadas', fontsize=18, fontweight='bold', y=1.02)

    # --- Row 1: Metricas Base ---

    # 1. order_item_count
    sns.countplot(x='order_item_count', data=features_df, palette='viridis', ax=axes[0, 0])
    axes[0, 0].set_title('1. Conteo de Art√≠culos por Pedido (order_item_count)')
    axes[0, 0].set_xlim(-0.5, features_df['order_item_count'].max() + 0.5)

    # 2. num_sellers
    sns.countplot(x='num_sellers', data=features_df, palette='plasma', ax=axes[0, 1])
    axes[0, 1].set_title('2. N√∫mero de Vendedores por Pedido (num_sellers)')
    axes[0, 1].set_xlim(-0.5, features_df['num_sellers'].max() + 0.5)

    # --- Row 2: Ratios Derivados ---

    # 3. freight_per_item
    limit_fpi = features_df['freight_per_item'].quantile(0.99)
    sns.histplot(features_df['freight_per_item'].dropna(), bins=50, kde=True, color='skyblue', ax=axes[1, 0])
    axes[1, 0].set_title('3. Flete Promedio por Art√≠culo (freight_per_item)')
    axes[1, 0].set_xlabel('Costo de Flete por Art√≠culo (R$)')
    if not np.isnan(limit_fpi) and limit_fpi > 0: axes[1, 0].set_xlim(0, limit_fpi)

    # 4. freight_ratio
    # Limitar la proporci√≥n a un valor razonable (ej. 1.0 = 100% del precio)
    limit_fr = features_df['freight_ratio'].quantile(0.99)
    sns.histplot(features_df['freight_ratio'].dropna(), bins=50, kde=True, color='lightcoral', ax=axes[1, 1])
    axes[1, 1].set_title('4. Proporci√≥n del Flete vs. Precio Total (freight_ratio)')
    axes[1, 1].set_xlabel('Flete / Precio Total')
    axes[1, 1].set_xlim(0, min(1.0, limit_fr) if not np.isnan(limit_fr) else 1.0)


    # --- Row 3: M√©tricas de Costo y Distancia ---

    # 5. avg_shipping_cost_per_kg
    # Convertir gramos a kg para la visualizaci√≥n si es necesario. La columna se calcula en g.
    limit_cost_kg = features_df['avg_shipping_cost_per_kg'].quantile(0.99)
    sns.histplot(features_df['avg_shipping_cost_per_kg'].dropna(), bins=50, kde=True, color='teal', ax=axes[2, 0])
    axes[2, 0].set_title('5. Costo de Env√≠o por Gramo (avg_shipping_cost_per_kg)')
    axes[2, 0].set_xlabel('Costo (R$) / Gramo')
    if not np.isnan(limit_cost_kg) and limit_cost_kg > 0: axes[2, 0].set_xlim(0, limit_cost_kg)

    # 6. shipping_distance_km
    limit_distance = features_df['shipping_distance_km'].quantile(0.99)
    sns.histplot(features_df['shipping_distance_km'].dropna(), bins=50, kde=True, color='grey', ax=axes[2, 1])
    axes[2, 1].set_title('6. Distancia de Env√≠o (shipping_distance_km)')
    axes[2, 1].set_xlabel('Distancia (Km)')
    if not np.isnan(limit_distance) and limit_distance > 0: axes[2, 1].set_xlim(0, limit_distance)

    plt.tight_layout()
    plt.show()

logistics_derived_features_df = generate_logistics_features(orders, order_items, products, sellers, customers, geolocation)
plot_derived_logistics_features(logistics_derived_features_df)

"""# Features de pago

```
| Nueva variable         | F√≥rmula / Fuente                 | Significado                                                          |
| ---------------------- | -------------------------------- | -------------------------------------------------------------------- |
| `num_categories`       | `nunique(product_category_name)` | Pedidos con categor√≠as diversas pueden implicar m√∫ltiples almacenes. |
| `most_common_category` | categor√≠a m√°s frecuente          | Algunas categor√≠as (ej. muebles) suelen tener m√°s retrasos.          |
| `avg_product_price`    | promedio de `price`              |                                                                      |
| `total_price`          | suma de `price`                  | Valor total del pedido.                                              |
| `avg_product_weight`   | promedio de `product_weight_g`   | Tama√±o promedio del producto.                                        |

```
"""

import pandas as pd
import numpy as np

# ASUMIMOS que 'order_payments' y 'order_items' est√°n cargados.

def generate_payment_features(order_payments_df: pd.DataFrame, order_items_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features de pago (valor, cuotas, tipo) y el ratio de pago vs. precio.
    Requiere order_payments y order_items.
    """

    # --- 1. PREPARACI√ìN ---
    order_payments_df = order_payments_df.copy()
    order_items_df = order_items_df.copy()

    # Coercionar a num√©rico y string de forma segura
    for df in [order_payments_df, order_items_df]:
        if 'order_id' in df.columns:
            df['order_id'] = df['order_id'].astype(str)

    order_payments_df['payment_value'] = pd.to_numeric(order_payments_df['payment_value'], errors='coerce')
    order_payments_df['payment_installments'] = pd.to_numeric(order_payments_df['payment_installments'], errors='coerce').fillna(0).astype(int)
    order_items_df['price'] = pd.to_numeric(order_items_df['price'], errors='coerce').fillna(0)


    # --- 2. CALCULAR TOTAL_PRICE (BASE) ---
    # Precio total del pedido es la suma de los precios de los √≠tems
    total_price_df = order_items_df.groupby('order_id')['price'].sum().reset_index(name='total_price')


    # --- 3. AGREGAR FEATURES DE PAGO ---
    # Un pedido puede tener m√∫ltiples pagos, por lo que agregamos a nivel de pedido.
    payment_agg = order_payments_df.groupby('order_id').agg(
        # payment_value: Suma total pagada
        payment_value=('payment_value', 'sum'),
        # payment_installments: M√°ximo de cuotas (ya que suelen ser consistentes o la mayor es la relevante)
        payment_installments=('payment_installments', 'max'),
        # is_boleto_payment: 1 si 'boleto' fue usado al menos una vez
        is_boleto_payment=('payment_type', lambda x: 1 if 'boleto' in x.values else 0)
    ).reset_index()


    # --- 4. MERGE Y C√ÅLCULO DE RATIO ---
    payment_features = payment_agg.merge(total_price_df, on='order_id', how='left')
    payment_features['total_price'] = payment_features['total_price'].fillna(0)

    # payment_ratio: Evitar divisi√≥n por cero
    payment_features['payment_ratio'] = np.where(
        payment_features['total_price'] > 0,
        payment_features['payment_value'] / payment_features['total_price'],
        np.nan
    )

    return payment_features

import matplotlib.pyplot as plt
import seaborn as sns

def plot_payment_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features de pago derivadas.
    """
    print("\n--- Generando Gr√°ficos de Features de Pago Derivadas ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Distribuci√≥n de Features de Pago y Ratios', fontsize=18, fontweight='bold', y=1.02)

    # 1. payment_value (Num√©rica)
    # Limitar al 99% para excluir outliers extremos de valor pagado
    safe_value_limit = features_df['payment_value'].quantile(0.99)
    sns.histplot(features_df['payment_value'].dropna(), bins=50, kde=True, color='teal', ax=axes[0, 0])
    axes[0, 0].set_title('1. Distribuci√≥n del Valor Total Pagado (**payment_value**)')
    axes[0, 0].set_xlabel('Valor Total Pagado (R$)')
    if not np.isnan(safe_value_limit) and safe_value_limit > 0:
        axes[0, 0].set_xlim(0, safe_value_limit)

    # 2. payment_installments (Num√©rica/Categ√≥rica)
    installments_data = features_df['payment_installments'].astype(int)
    sns.countplot(x=installments_data, color='darkred', ax=axes[0, 1])
    axes[0, 1].set_title('2. Conteo por N√∫mero M√°ximo de Cuotas (**payment_installments**)')
    axes[0, 1].set_xlabel('N√∫mero de Cuotas')
    # Enfocarse en las cuotas m√°s comunes (hasta 12)
    axes[0, 1].set_xlim(-0.5, 12.5)

    # 3. is_boleto_payment (Binaria)
    sns.countplot(x='is_boleto_payment', data=features_df, palette=['forestgreen', 'firebrick'], ax=axes[1, 0])
    axes[1, 0].set_title('3. Riesgo de Retraso por Tipo de Pago (**is_boleto_payment**)')
    axes[1, 0].set_xlabel('1 = Pago con Boleto (Riesgo), 0 = Sin Boleto')

    # 4. payment_ratio (Ratio)
    ratio_data = features_df['payment_ratio'].replace([np.inf, -np.inf], np.nan).dropna()
    safe_ratio_limit = ratio_data.quantile(0.99)
    # Limitar el eje X para visualizar la distribuci√≥n alrededor de 1.0
    plot_limit = min(2.0, safe_ratio_limit) if not np.isnan(safe_ratio_limit) else 2.0

    sns.histplot(ratio_data, bins=50, kde=True, color='purple', ax=axes[1, 1])
    axes[1, 1].set_title('4. Ratio de Pago vs. Precio (**payment_ratio**)')
    axes[1, 1].set_xlabel('Valor Pagado / Precio Total')
    axes[1, 1].set_xlim(0, plot_limit)

    plt.tight_layout()
    plt.show()

payment_features_df = generate_payment_features(order_payments, order_items)
plot_payment_features(payment_features_df)

"""# Features geogr√°ficas (distancia y regiones)

```
| Nueva variable    | Descripci√≥n                                                                    |
| ----------------- | ------------------------------------------------------------------------------ |
| `geo_distance_km` | distancia promedio entre cliente y vendedor (por coordenadas de `geolocation`) |
| `same_state`      | 1 si `customer_state == seller_state`                                          |
| `region_pair`     | combinaci√≥n estado_cliente + estado_vendedor (√∫til para encoding)              |

```
"""

import pandas as pd
import numpy as np
from math import radians, sin, cos, sqrt, atan2

# ASUMIMOS que 'orders', 'customers', 'sellers', 'order_items', 'geolocation' est√°n cargados.

# --- 1. Funci√≥n para calcular Distancia Haversine ---
def haversine_distance(lat1, lon1, lat2, lon2):
    """Calcula la distancia Haversine (en km) entre dos puntos geogr√°ficos."""
    R = 6371  # Radio de la Tierra en kil√≥metros

    # Convertir grados a radianes
    lat1_rad, lon1_rad = radians(lat1), radians(lon1)
    lat2_rad, lon2_rad = radians(lat2), radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    a = sin(dlat / 2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = R * c
    return distance

# --- 2. Funci√≥n Principal para Generar Features ---
def generate_geo_features(orders_df: pd.DataFrame, customers_df: pd.DataFrame,
                          sellers_df: pd.DataFrame, order_items_df: pd.DataFrame,
                          geolocation_df: pd.DataFrame) -> pd.DataFrame:
    """
    Genera features de distancia geogr√°fica y de estado entre cliente y vendedor.
    """

    # Preparaci√≥n de DataFrames
    orders_df['order_id'] = orders_df['order_id'].astype(str)

    # 2.1. Limpieza y Agregaci√≥n de Geolocation (Centroide por ZIP)
    geo_df = geolocation_df[['geolocation_zip_code_prefix', 'geolocation_lat', 'geolocation_lng']].copy()
    geo_df['geolocation_zip_code_prefix'] = pd.to_numeric(geo_df['geolocation_zip_code_prefix'], errors='coerce')

    # Calcular el centroide (promedio) de lat/lng para cada ZIP
    geo_centroids = geo_df.groupby('geolocation_zip_code_prefix').agg(
        lat=('geolocation_lat', 'mean'),
        lng=('geolocation_lng', 'mean')
    ).reset_index()

    # 2.2. Emparejar Cliente y Vendedor

    # Clientes y sus Zips
    customer_loc = customers_df[['customer_id', 'customer_zip_code_prefix', 'customer_state']].merge(
        orders_df[['customer_id', 'order_id']], on='customer_id', how='right'
    )
    customer_loc['customer_zip_code_prefix'] = pd.to_numeric(customer_loc['customer_zip_code_prefix'], errors='coerce')

    # Vendedores y sus Zips (un pedido puede tener m√∫ltiples vendedores, tomamos la primera ubicaci√≥n como proxy si es necesario)
    seller_loc = sellers_df[['seller_id', 'seller_zip_code_prefix', 'seller_state']].merge(
        order_items_df[['seller_id', 'order_id']].drop_duplicates(subset='order_id'), on='seller_id', how='right'
    )
    seller_loc['seller_zip_code_prefix'] = pd.to_numeric(seller_loc['seller_zip_code_prefix'], errors='coerce')


    # 2.3. Merge de Ubicaciones y Geocoordenadas
    df_merged = customer_loc.merge(
        seller_loc[['order_id', 'seller_zip_code_prefix', 'seller_state']], on='order_id', how='inner'
    )

    # Merge con coordenadas del cliente
    df_merged = df_merged.merge(
        geo_centroids.rename(columns={'geolocation_zip_code_prefix': 'customer_zip_code_prefix', 'lat': 'cust_lat', 'lng': 'cust_lng'}),
        on='customer_zip_code_prefix', how='left'
    )

    # Merge con coordenadas del vendedor
    df_merged = df_merged.merge(
        geo_centroids.rename(columns={'geolocation_zip_code_prefix': 'seller_zip_code_prefix', 'lat': 'seller_lat', 'lng': 'seller_lng'}),
        on='seller_zip_code_prefix', how='left'
    )


    # --- 3. C√ÅLCULO DE FEATURES ---

    # geo_distance_km
    # Aplicar Haversine solo si todas las coordenadas est√°n presentes
    df_merged['geo_distance_km'] = df_merged.apply(
        lambda row: haversine_distance(row['cust_lat'], row['cust_lng'], row['seller_lat'], row['seller_lng'])
        if all(pd.notna(row[['cust_lat', 'cust_lng', 'seller_lat', 'seller_lng']])) else np.nan,
        axis=1
    )

    # same_state (Binaria)
    df_merged['same_state'] = (df_merged['customer_state'] == df_merged['seller_state']).astype(int)

    # region_pair (Categ√≥rica)
    df_merged['region_pair'] = df_merged['customer_state'].astype(str) + '_' + df_merged['seller_state'].astype(str)


    return df_merged[['order_id', 'geo_distance_km', 'same_state', 'region_pair']].copy()

import matplotlib.pyplot as plt
import seaborn as sns

def plot_geo_features(features_df: pd.DataFrame):
    """
    Genera gr√°ficos para las features geogr√°ficas.
    """
    print("\n--- Generando Gr√°ficos de Features Geogr√°ficas ---")

    sns.set_style("whitegrid")

    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    fig.suptitle('Distribuci√≥n de Distancia y Complejidad Geogr√°fica', fontsize=18, fontweight='bold', y=1.08)

    # 1. geo_distance_km (Num√©rica)
    # Limitar al 99% para excluir outliers extremos
    safe_dist_limit = features_df['geo_distance_km'].quantile(0.99)
    sns.histplot(features_df['geo_distance_km'].dropna(), bins=50, kde=True, color='darkblue', ax=axes[0])
    axes[0].set_title('1. Distribuci√≥n de Distancia de Env√≠o (geo_distance_km)')
    axes[0].set_xlabel('Distancia (Km)')
    if not np.isnan(safe_dist_limit) and safe_dist_limit > 0:
        axes[0].set_xlim(0, safe_dist_limit)
    axes[0].axvline(features_df['geo_distance_km'].median(), color='red', linestyle='--', label='Mediana')
    axes[0].legend()


    # 2. same_state (Binaria)
    sns.countplot(x='same_state', data=features_df, palette=['firebrick', 'forestgreen'], ax=axes[1])
    axes[1].set_title('2. Pedidos Dentro del Mismo Estado (same_state)')
    axes[1].set_xlabel('0 = Cruza Estado, 1 = Mismo Estado')


    # 3. region_pair (Top 10)
    top_pairs = features_df['region_pair'].value_counts().nlargest(10).index
    sns.countplot(y='region_pair', data=features_df, order=top_pairs, palette='magma', ax=axes[2])
    axes[2].set_title('3. Top 10 Pares de Regiones (Cliente_Vendedor)')
    axes[2].set_xlabel('Conteo de Pedidos')

    plt.tight_layout()
    plt.show()

def plot_same_state(features_df: pd.DataFrame):
    """
    Grafica la distribuci√≥n de pedidos seg√∫n si cruzan estado o no.
    """
    sns.set_style("whitegrid")
    plt.figure(figsize=(6, 5))
    sns.countplot(x='same_state', data=features_df, palette=['firebrick', 'forestgreen'])
    plt.title('2. Pedidos Dentro del Mismo Estado (same_state)', fontsize=14, fontweight='bold')
    plt.xlabel('0 = Cruza Estado, 1 = Mismo Estado')
    plt.tight_layout()
    plt.show()

geo_features_df = generate_geo_features(orders, customers, sellers, order_items, geolocation)
# print(geo_features_df.head())
plot_geo_features(geo_features_df)

"""# Formulacion del problema
La empresa Olist, que act√∫a como intermediario entre m√∫ltiples vendedores y clientes en todo Brasil, enfrenta el desaf√≠o de anticipar qu√© pedidos presentan mayor probabilidad de retraso, considerando la gran diversidad geogr√°fica del pa√≠s, los diferentes tipos de productos, los m√©todos de pago y las condiciones log√≠sticas de cada vendedor.

# Formulacion de la hipotesis

El tiempo de entrega de un pedido en el marketplace Olist puede predecirse con alta precisi√≥n mediante variables log√≠sticas y geogr√°ficas, tales como la ubicaci√≥n del cliente y del vendedor, el peso del producto, el costo del flete y el tipo de pago utilizado.

# Target1: is_late_delivery

El target preliminar del modelo es is_late_delivery, el cual se calcula de la siguiente manera:



```
Valor	Significado	Condici√≥n
1   	Retrasada	  order_delivered_customer_date > order_estimated_delivery_date
0	    A tiempo	  order_delivered_customer_date <= order_estimated_delivery_date
```

# Target 2: delay_days
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def calculate_delay_days(orders_df: pd.DataFrame) -> pd.DataFrame:
    """
    Calcula la variable num√©rica 'delay_days' para las √≥rdenes entregadas.

    Args:
        orders_df (pd.DataFrame): DataFrame de √≥rdenes. Se asume que las columnas
                                  de fecha ya son de tipo datetime.

    Returns:
        pd.DataFrame: DataFrame con la columna 'delay_days' agregada.
    """
    df = orders_df.copy()

    # Asegurarse de que solo trabajamos con √≥rdenes entregadas para el c√°lculo
    df_delivered = df[df['order_status'] == 'delivered'].copy()

    # 1. Calcular la diferencia temporal (intervalo de tiempo)
    # Si Delivered > Estimated, el resultado es positivo (retraso).
    # Si Delivered <= Estimated, el resultado es negativo o cero (a tiempo/temprano).
    df_delivered['delivery_diff'] = (
        df_delivered['order_delivered_customer_date'] -
        df_delivered['order_estimated_delivery_date']
    )

    # 2. Convertir la diferencia de tiempo a d√≠as num√©ricos
    # Convertir Timedelta a float (d√≠as)
    df_delivered['delay_days'] = df_delivered['delivery_diff'].dt.total_seconds() / (60*60*24)

    # 3. Aplicar la l√≥gica de negocio: Solo nos interesa el retraso (valores > 0)
    # Usamos np.clip para establecer todos los valores negativos o cero a cero.
    df_delivered['delay_days'] = np.clip(df_delivered['delay_days'], a_min=0, a_max=None)

    # Devolver solo las columnas relevantes
    return df_delivered[['order_id', 'order_status', 'order_delivered_customer_date',
                         'order_estimated_delivery_date', 'delay_days']].copy()

def plot_delay_days(delay_df: pd.DataFrame):
    """
    Genera gr√°ficos de distribuci√≥n para la variable 'delay_days'.

    Args:
        delay_df (pd.DataFrame): DataFrame que contiene la columna 'delay_days'.
    """
    sns.set_style("whitegrid")

    # Filtramos solo los pedidos con retraso (delay_days > 0)
    retrasos = delay_df[delay_df['delay_days'] > 0]['delay_days'].dropna()

    if retrasos.empty:
        print("No se encontraron pedidos con retraso para graficar.")
        return

    # Usamos el percentil 99 para excluir outliers extremos de retraso
    limit = retrasos.quantile(0.99)

    fig, ax = plt.subplots(figsize=(12, 6))

    # Histograma de los d√≠as de retraso
    sns.histplot(retrasos, bins=50, kde=True, color='darkorange', ax=ax)

    # L√≠neas de referencia para la mediana y el 99%
    median_delay = retrasos.median()

    ax.axvline(median_delay, color='red', linestyle='--', label=f'Mediana: {median_delay:.1f} d√≠as')
    ax.axvline(retrasos.mean(), color='blue', linestyle=':', label=f'Media: {retrasos.mean():.1f} d√≠as')

    ax.set_title(f'Distribuci√≥n de la Gravedad del Retraso (Pedidos con Retraso, N={len(retrasos):,})',
                 fontsize=16, fontweight='bold', y=1.03)
    ax.set_xlabel('D√≠as de Retraso (delay_days)', fontsize=12)
    ax.set_ylabel('Frecuencia', fontsize=12)

    # Limitar el eje X al percentil 99 para mejor visualizaci√≥n
    ax.set_xlim(0, limit)
    ax.legend(loc='best')

    plt.tight_layout()
    plt.show()

delay_features_df = calculate_delay_days(orders)

plot_delay_days(delay_features_df)

"""# Justificacion de la hipotesis"""

analyze_delivery_timeline(orders)

"""lo mas obvio: distancia


"""

plot_same_state(geo_features_df)

plot_monthly_category_sales_trend(orders, order_items, products)
plot_top_10_monthly_category_sales(orders, order_items, products)

plot_purchase_hour_distribution(temporal_features_df)

plot_seller_state_distribution(logistics_features_df)
plot_shipping_distance_distribution(logistics_features_df)

"""Boleto:
1. Al comprar un producto o servicio en Brasil, se genera un boleto para la compra.
2. El comprador recibe el boleto (impreso o virtual) con un c√≥digo de barras.
3. El comprador paga el boleto en uno de los lugares autorizados utilizando efectivo o transferencia.
4. Una vez que el pago se procesa, el comerciante recibe la notificaci√≥n y el pedido se atiende.
"""

plot_payment_type_total_value(order_payments)

"""# Baseline"""

print(orders_delivered['is_late_delivery'].value_counts(normalize=True) * 100)

plot_target_distribution_series(orders_delivered['is_late_delivery'])

"""# Metricas

M√©trica	Descripci√≥n	Por qu√© es importante para la Detecci√≥n de Retrasos
1. F1-Score	Es la media arm√≥nica entre Precisi√≥n y Recall. Combina ambas m√©tricas en un solo valor para evaluar el rendimiento general de un modelo.	La m√©trica de balance ideal. Dado que un retraso es un evento relativamente raro (clase minoritaria), el F1-Score garantiza que estamos optimizando tanto la detecci√≥n de retrasos reales (Recall) como la fiabilidad de las predicciones de retraso (Precision).
2. Recall	Mide la proporci√≥n de casos positivos (√≥rdenes con retraso) correctamente identificados por el modelo respecto al total de positivos reales.	Minimizar el riesgo. Si el coste de no detectar un retraso (Falso Negativo) es alto (p.ej., el costo de una mala experiencia del cliente o de un reembolso), el Recall debe ser la m√©trica principal. Indica qu√© tan bien detectamos todos los casos de inter√©s.
3. Precision	Es la proporci√≥n de casos positivos predichos correctamente entre todos los casos que el modelo clasific√≥ como positivos.	Optimizar recursos. Si el coste de actuar sobre una falsa alarma (Falso Positivo) es alto (p.ej., el costo de alertar a un vendedor o transportista innecesariamente), la Precisi√≥n es la m√©trica m√°s importante. Indica la confiabilidad de nuestras predicciones de retraso.
4. Accuracy	Es la proporci√≥n de predicciones correctas (positivas y negativas) sobre el total de casos evaluados. Mide el rendimiento global del modelo.	Riesgo en datos desbalanceados. Es √∫til como m√©trica global simple, pero puede ser enga√±osa. Si el 95% de los pedidos est√°n a tiempo, un modelo que siempre predice "A Tiempo" tendr√° un 95% de Accuracy, lo cual es in√∫til para detectar el 5% de retrasos.
5. ROC-AUC	Mide la capacidad del modelo para distinguir entre las clases (retraso vs. a tiempo) a trav√©s de todos los umbrales de clasificaci√≥n posibles. Representa el √°rea bajo la curva ROC (Tasa de Verdaderos Positivos vs. Tasa de Falsos Positivos).	Es fundamental en clases desbalanceadas. Proporciona una visi√≥n completa del rendimiento del modelo independientemente del umbral de clasificaci√≥n elegido, asegurando que el modelo tiene un buen poder predictivo en general, no solo en un punto espec√≠fico.
"""

